(()=>{"use strict";var __webpack_modules__={417:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "q": () => (/* binding */ apiKey),\n  "_": () => (/* binding */ locationInput)\n});\n\n;// CONCATENATED MODULE: ./src/metUtil.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction getLocationCoords() {\n  return _getLocationCoords.apply(this, arguments);\n}\nfunction _getLocationCoords() {\n  _getLocationCoords = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var locationInputValue, locationCoordsUrl, response, resData, _ref, lat, lon, elevation;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          locationInputValue = locationInput.value || \'Budapest\';\n          locationCoordsUrl = "http://api.openweathermap.org/geo/1.0/direct?q=".concat(locationInputValue, "&limit=5&appid=").concat(apiKey);\n          _context.next = 5;\n          return fetch(locationCoordsUrl, {\n            mode: \'cors\'\n          });\n        case 5:\n          response = _context.sent;\n          _context.next = 8;\n          return response.json();\n        case 8:\n          resData = _context.sent;\n          _ref = [resData[0].lat, resData[0].lon], lat = _ref[0], lon = _ref[1];\n          _context.next = 12;\n          return getLocationElevation(lat, lon);\n        case 12:\n          elevation = _context.sent;\n          console.log(elevation);\n          return _context.abrupt("return", [lat, lon, elevation]);\n        case 17:\n          _context.prev = 17;\n          _context.t0 = _context["catch"](0);\n          console.log(_context.t0);\n        case 20:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, null, [[0, 17]]);\n  }));\n  return _getLocationCoords.apply(this, arguments);\n}\nfunction setBackgroundImg(_x) {\n  return _setBackgroundImg.apply(this, arguments);\n}\nfunction _setBackgroundImg() {\n  _setBackgroundImg = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(weatherDesc) {\n    var response, imgData, randomImgFromQuery;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return fetch("https://api.unsplash.com/search/photos?&query=".concat(weatherDesc, "&orientation=landscape&client_id=inUZHZYqQ-h7kGW3jhjv0-eVwJIrOsL9YATL4AdZ4i0"), {\n            mode: \'cors\'\n          });\n        case 2:\n          response = _context2.sent;\n          _context2.next = 5;\n          return response.json();\n        case 5:\n          imgData = _context2.sent;\n          randomImgFromQuery = Math.floor(Math.random() * imgData.results.length);\n          setCustomCSSProperty(\'--bg-img\', "url(".concat(imgData.results[randomImgFromQuery].urls.full, ")"));\n        case 8:\n        case "end":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _setBackgroundImg.apply(this, arguments);\n}\nfunction setCustomCSSProperty(propertyName, newPropValue) {\n  document.documentElement.style.setProperty(propertyName, newPropValue);\n}\nfunction calculateWindDirection(deg) {\n  return Math.abs(360 - (180 - deg));\n}\nfunction getLocationElevation(_x2, _x3) {\n  return _getLocationElevation.apply(this, arguments);\n}\nfunction _getLocationElevation() {\n  _getLocationElevation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(lat, lon) {\n    var req, reqRes;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n          _context3.next = 3;\n          return fetch("https://api.opentopodata.org/v1/eudem25m?locations=".concat(lat, ",").concat(lon));\n        case 3:\n          req = _context3.sent;\n          _context3.next = 6;\n          return req.json();\n        case 6:\n          reqRes = _context3.sent;\n          return _context3.abrupt("return", reqRes.results[0].elevation);\n        case 10:\n          _context3.prev = 10;\n          _context3.t0 = _context3["catch"](0);\n          return _context3.abrupt("return", 0);\n        case 13:\n        case "end":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[0, 10]]);\n  }));\n  return _getLocationElevation.apply(this, arguments);\n}\n;// CONCATENATED MODULE: ./src/forecastWeather.js\nfunction forecastWeather_typeof(obj) { "@babel/helpers - typeof"; return forecastWeather_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, forecastWeather_typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction forecastWeather_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ forecastWeather_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == forecastWeather_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction forecastWeather_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction forecastWeather_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { forecastWeather_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { forecastWeather_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\nvar feelsLikeIconSVG = "\\n<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 32 32\\"><path fill=\\"currentColor\\" d=\\"M26 30h-4a2.006 2.006 0 0 1-2-2v-7a2.006 2.006 0 0 1-2-2v-6a2.946 2.946 0 0 1 3-3h6a2.946 2.946 0 0 1 3 3v6a2.006 2.006 0 0 1-2 2v7a2.006 2.006 0 0 1-2 2zm-5-18a.945.945 0 0 0-1 1v6h2v9h4v-9h2v-6a.945.945 0 0 0-1-1zm3-3a4 4 0 1 1 4-4a4.012 4.012 0 0 1-4 4zm0-6a2 2 0 1 0 2 2a2.006 2.006 0 0 0-2-2zM10 20.184V12H8v8.184a3 3 0 1 0 2 0z\\"/><path fill=\\"currentColor\\" d=\\"M9 30a6.993 6.993 0 0 1-5-11.89V7a5 5 0 0 1 10 0v11.11A6.993 6.993 0 0 1 9 30ZM9 4a3.003 3.003 0 0 0-3 3v11.983l-.332.299a5 5 0 1 0 6.664 0L12 18.983V7a3.003 3.003 0 0 0-3-3Z\\"/></svg>\\n";\nfunction getForecastWeatherHTML() {\n  return _getForecastWeatherHTML.apply(this, arguments);\n}\nfunction _getForecastWeatherHTML() {\n  _getForecastWeatherHTML = forecastWeather_asyncToGenerator( /*#__PURE__*/forecastWeather_regeneratorRuntime().mark(function _callee() {\n    var forecastWeatherData, usedForecastData, forecastErrDiv;\n    return forecastWeather_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return fetchForecastWeatherData();\n        case 3:\n          forecastWeatherData = _context.sent;\n          usedForecastData = getUsedForecastData(forecastWeatherData);\n          return _context.abrupt("return", createForecastWeatherHTML(usedForecastData));\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context["catch"](0);\n          forecastErrDiv = document.createElement(\'div\');\n          forecastErrDiv.innerHTML = "\\n        <div class=\\"forecast-weather weather-card flex-center-column\\">\\n            <h2>Please try again!</h2>\\n            <h4>The data didn\'t reach us or the location was not found!</h4>\\n        </div>";\n          return _context.abrupt("return", forecastErrDiv);\n        case 13:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, null, [[0, 8]]);\n  }));\n  return _getForecastWeatherHTML.apply(this, arguments);\n}\nfunction fetchForecastWeatherData() {\n  return _fetchForecastWeatherData.apply(this, arguments);\n}\nfunction _fetchForecastWeatherData() {\n  _fetchForecastWeatherData = forecastWeather_asyncToGenerator( /*#__PURE__*/forecastWeather_regeneratorRuntime().mark(function _callee2() {\n    var _yield$getLocationCoo, _yield$getLocationCoo2, lat, lon, elev, url, response, resData;\n    return forecastWeather_regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return getLocationCoords();\n        case 2:\n          _yield$getLocationCoo = _context2.sent;\n          _yield$getLocationCoo2 = _slicedToArray(_yield$getLocationCoo, 3);\n          lat = _yield$getLocationCoo2[0];\n          lon = _yield$getLocationCoo2[1];\n          elev = _yield$getLocationCoo2[2];\n          url = "https://api.openweathermap.org/data/2.5/forecast?lat=".concat(lat, "&lon=").concat(lon, "&appid=").concat(apiKey, "&units=metric");\n          _context2.next = 10;\n          return fetch(url);\n        case 10:\n          response = _context2.sent;\n          _context2.next = 13;\n          return response.json();\n        case 13:\n          resData = _context2.sent;\n          return _context2.abrupt("return", resData);\n        case 15:\n        case "end":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _fetchForecastWeatherData.apply(this, arguments);\n}\nfunction getUsedForecastData(forecastObj) {\n  var forecastWeather = [];\n  var forecastWeatherDaily = {};\n  var weekDays = [\'Sunday\', \'Monday\', \'Tuesday\', \'Wednesday\', \'Thursday\', \'Friday\', \'Saturday\'];\n  forecastObj.list.forEach(function (threeHourForecast) {\n    var usedThreeHourData = {\n      forecastDateTime: threeHourForecast.dt_txt,\n      forecastDay: weekDays[new Date(threeHourForecast.dt_txt.substring(0, 10)).getUTCDay()],\n      forecastTime: threeHourForecast.dt_txt.substring(10, 16),\n      forecastDayPeriod: threeHourForecast.sys.pod,\n      forecastIcon: threeHourForecast.weather[0].icon,\n      forecastDesc: threeHourForecast.weather[0].main,\n      forecastTempFelt: threeHourForecast.main.feels_like,\n      forecastTemp: threeHourForecast.main.temp,\n      forecastWindDir: threeHourForecast.wind.deg,\n      forecastWindSpeed: threeHourForecast.wind.speed,\n      forecastWindGust: threeHourForecast.wind.gust\n    };\n    forecastWeather.push(usedThreeHourData);\n  });\n  forecastWeather.forEach(function (forecastObj) {\n    if (!forecastWeatherDaily[forecastObj.forecastDay]) {\n      forecastWeatherDaily[forecastObj.forecastDay] = [];\n    }\n    forecastWeatherDaily[forecastObj.forecastDay].push(forecastObj);\n  });\n  return forecastWeatherDaily;\n}\nfunction createForecastWeatherHTML(usedForecastDataArr) {\n  var days = Object.keys(usedForecastDataArr);\n  setCustomCSSProperty(\'--forecast-grid-num\', days.length);\n  var forecastWeatherDiv = document.createElement(\'div\');\n  forecastWeatherDiv.classList.add(\'forecast-weather\', \'weather-card\', \'flex-center\');\n  var _loop = function _loop() {\n    var dayDiv = document.createElement(\'div\');\n    dayDiv.classList.add(\'forecast-day\', "forecast-day-".concat(i), "".concat(days[i]), \'flex-center-column\');\n    dayDiv.innerHTML = "<h3>".concat(days[i], "</h3>\\n                            <div class=\\"daily-weather-forecast-wrapper flex-center\\"></div>");\n    usedForecastDataArr[days[i]].forEach(function (threeHourForecast) {\n      var imgURL = "http://openweathermap.org/img/wn/".concat(threeHourForecast.forecastIcon, "@2x.png");\n      var windArrowDeg = calculateWindDirection(threeHourForecast.forecastWindDir);\n      var dailyWeatherForecastTemplate = dayDiv.querySelector(\'.daily-weather-forecast-wrapper\');\n      var threeHourTemplate = "\\n                <div class=\\"daily-weather-3-hour flex-center-column weather-card-data-group\\">\\n                    <div class=\\"weather-icon flex-center-column\\">\\n                        <h5>".concat(threeHourForecast.forecastTime, "</h5>\\n                        <img src=\\"").concat(imgURL, "\\" alt=\\"").concat(threeHourForecast.forecastDesc, "\\">\\n                        <h6>").concat(threeHourForecast.forecastDesc, "</h6>\\n                    </div>\\n                    <div class=\\"weather-temp flex-center-column\\">\\n                        <h6>").concat(Number.parseFloat(threeHourForecast.forecastTemp).toFixed(1), " \\xB0C</h6>\\n                        <div style=\\"height: 65px;\\" class=\\"flex-center-column\\">\\n                            <h5 >Feels like:</h5>\\n                            <h5>").concat(Number.parseFloat(threeHourForecast.forecastTempFelt).toFixed(1), " \\xB0C</h5>\\n                        </div>\\n                    </div>\\n                    <div class=\\"weather-wind flex-center-column\\">\\n                        <svg style=\\"transform: rotate(").concat(windArrowDeg, "deg);\\" xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"32\\" height=\\"32\\" viewBox=\\"0 0 24 24\\"><path fill=\\"currentColor\\" d=\\"M13 18h-2v-8l-3.5 3.5l-1.42-1.42L12 6.16l5.92 5.92l-1.42 1.42L13 10v8M12 2a10 10 0 0 1 10 10a10 10 0 0 1-10 10A10 10 0 0 1 2 12A10 10 0 0 1 12 2m0 2a8 8 0 0 0-8 8a8 8 0 0 0 8 8a8 8 0 0 0 8-8a8 8 0 0 0-8-8Z\\"/></svg>\\n                        <h5>").concat(Number.parseFloat(threeHourForecast.forecastWindSpeed).toFixed(1), " m/s</h5>\\n                        <h6>").concat(Number.parseFloat(threeHourForecast.forecastWindGust).toFixed(1), " m/s</h6>\\n                    </div>\\n                </div>\\n                ");\n      dailyWeatherForecastTemplate.insertAdjacentHTML(\'beforeend\', threeHourTemplate);\n    });\n    forecastWeatherDiv.insertAdjacentElement(\'beforeend\', dayDiv);\n  };\n  for (var i = 0; i <= days.length - 1; i++) {\n    _loop();\n  }\n  return forecastWeatherDiv;\n}\n;// CONCATENATED MODULE: ./node_modules/velitherm/dist/es/index.js\n/**\n * velivole.fr/meteo.guru Basic Thermodynamics Equations for Soaring Flight\n *\n * Copyright © 2022 Momtchil Momtchev <momtchil@momtchev.com>\n *\n * Licensed under the LGPL License, Version 3.0 (the "License")\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at: https://www.gnu.org/licenses/lgpl-3.0.en.html\n *\n * All methods use:\n *\n * Pressure in hPa\n *\n * Temperature in °C\n *\n * Height in meters\n *\n * Relative humidity in % from 0 to 100\n *\n * Specific humidity in g/kg\n *\n * Mixing ratio in g/kg\n */\nvar velitherm = \'velitherm\';\n/**\n * Earth\'s average gravity acceleration (m/s2)\n *\n * @const\n * @type {number}\n */\nvar G = 9.81;\n/**\n * The thermal capacity of air (J/kg)\n *\n * @const\n * @type {number}\n */\nvar Cp = 1005;\n/**\n * The enthalpy of vaporization of water (J/kg)\n *\n * @const\n * @type {number}\n */\nvar L = 2.5e6;\n/**\n * The adiabatic lapse rate of dry air (°C/m)\n *\n * @const\n * @type {number}\n */\nvar gamma = 0.00976;\n/**\n * The average sea level pressure (hPa)\n *\n * @const\n * @type {number}\n */\nvar P0 = 1013.25;\n/**\n * The temperature of the ICAO standard atmosphere (°C)\n *\n * @const\n * @type {number}\n */\nvar T0 = 15;\n/**\n * The specific gas constant of dry air J/(kg*K)\n *\n * @const\n * @type {number}\n */\nvar Rd = 287.058;\n/**\n * The specific gas constant of water vapor J/(kg*K)\n *\n * @const\n * @type {number}\n */\nvar Rv = 461.495;\n/**\n * Molar mass of dry air kg/mol\n *\n * @const\n * @type {number}\n */\nvar Md = 0.0289652;\n/**\n * Molar mass of water vapor kg/mol\n *\n * @const\n * @type {number}\n */\nvar Mv = 0.018016;\n/**\n * Universal gas constant J/(kg*mol)\n *\n * @const\n * @type {number}\n */\nvar R = 8.31446;\n/**\n * Absolute zero in °C\n *\n * @const\n * @type {number}\n */\nvar K = -273.15;\n/**\n * Altitude from pressure using the barometric formula and ICAO\'s definition of standard atmosphere.\n *\n * This is a very rough approximation that is an ICAO standard. It is used when calculating QNH.\n * It does not take into account the pressure and temperature of the day.\n *\n * @param {number} pressure Pressure\n * @param {number} [pressure0] Optional sea-level pressure of the day\n * @returns {number}\n */\nfunction altitudeFromStandardPressure(pressure, pressure0) {\n    if (pressure0 === void 0) { pressure0 = P0; }\n    return 44330.0 * (1.0 - Math.pow(pressure / pressure0, 1 / 5.255));\n}\n/**\n * Pressure from altitude using the barometric formula and ICAO\'s definition of standard atmosphere.\n *\n * This is a very rough approximation that is an ICAO standard. It is used when calculating QNH.\n * It does not take into account the pressure and temperature of the day.\n *\n * @param {number} height Height\n * @param {number} [pressure0] Optional sea-level pressure of the day\n * @returns {number}\n */\nfunction pressureFromStandardAltitude(height, pressure0) {\n    if (pressure0 === void 0) { pressure0 = P0; }\n    return pressure0 * Math.pow(1 - height / 44330.0, 5.255);\n}\n/**\n * Altitude from pressure using the hypsometric formula.\n *\n * This is a better equation that takes into account the pressure and the temperature of the day.\n * It is not a standard and different weather institutions use slightly different parameters.\n * It is used when calculating the QFF.\n *\n * @param {number} pressure Pressure\n * @param {number} [pressure0] Optional sea-level pressure of the day\n * @param {number} [temp] Optional average temperature from the ground to the given level\n * @returns {number}\n */\nfunction altitudeFromPressure(pressure, pressure0, temp) {\n    if (pressure0 === void 0) { pressure0 = P0; }\n    if (temp === void 0) { temp = T0; }\n    return (Math.pow(pressure0 / pressure, 1.0 / 5.257) - 1) * (temp - K) / 0.0065;\n}\n/**\n * Pressure from altitude using the hypsometric formula.\n *\n * This is a better equation that takes into account the pressure and the temperature of the day.\n * It is not a standard and different weather institutions use slightly different parameters.\n * It is used when calculating the QFF.\n *\n * @param {number} height Height\n * @param {number} [pressure0] Optional sea-level pressure of the day\n * @param {number} [temp] Optional average temperature from the ground to the given level\n * @returns {number}\n */\nfunction pressureFromAltitude(height, pressure0, temp) {\n    if (pressure0 === void 0) { pressure0 = P0; }\n    if (temp === void 0) { temp = T0; }\n    return pressure0 * Math.pow(1.0 - 0.0065 * height / (temp - K + 0.0065 * height), 5.257);\n}\n/**\n * (Saturation) Water vapor pressure.\n *\n * Clausius–Clapeyron equation - the most fundamental equation in weather science.\n *\n * This is the Magnus-Tetens approximation.\n *\n * @param {number} temp Temperature\n * @returns {number}\n */\nfunction waterVaporSaturationPressure(temp) {\n    if (temp === void 0) { temp = T0; }\n    return 6.1078 * Math.exp(17.27 * temp / (temp + 237.3));\n}\n/**\n * Relative humidity from specific humidity.\n *\n * This is from the Magnus-Tetens approximation.\n *\n * @param {number} specificHumidity Specific humidity\n * @param {number} [pressure] Optional pressure\n * @param {number} [temp] Optional temperature\n * @returns {number}\n */\nfunction relativeHumidity(specificHumidity, pressure, temp) {\n    if (pressure === void 0) { pressure = P0; }\n    if (temp === void 0) { temp = T0; }\n    return specificHumidity / (6.22 * waterVaporSaturationPressure(temp) / pressure);\n}\nvar Sonntag_1990_b = 17.62;\nvar Sonntag_1990_c = 243.12;\n/**\n * Dew point from relative humidity.\n *\n * Approximation of the Magnus equation with the Sonntag 1990 coefficients.\n *\n * @param {number} relativeHumidity Relative humidity\n * @param {number} [temp] Optional temperature\n * @returns {number}\n */\nfunction dewPoint(relativeHumidity, temp) {\n    if (temp === void 0) { temp = T0; }\n    var gamma = Math.log(relativeHumidity / 100) + Sonntag_1990_b * temp / (Sonntag_1990_c + temp);\n    return Sonntag_1990_c * gamma / (Sonntag_1990_b - gamma);\n}\n/**\n * Relative humidity from dew point.\n *\n * Approximation of the Magnus equation with the Sonntag 1990 coefficients.\n *\n * @param {number} dewPoint Relative humidity\n * @param {number} [temp] Optional temperature\n * @returns {number}\n */\nfunction relativeHumidityFromDewPoint(dewPoint, temp) {\n    if (temp === void 0) { temp = T0; }\n    var gamma = dewPoint * Sonntag_1990_b / (dewPoint + Sonntag_1990_c);\n    return Math.exp(gamma - Sonntag_1990_b * temp / (Sonntag_1990_c + temp)) * 100;\n}\n/**\n * Mixing ratio from specific humidity.\n *\n * Analytic equation from the definition.\n *\n * @param {number} specificHumidity Specific humidity\n * @returns {number}\n */\nfunction mixingRatio(specificHumidity) {\n    return specificHumidity / (1 - specificHumidity / 1000);\n}\n/**\n * Specific humidity from mixing ratio.\n *\n * Analytic equation from the definition.\n *\n * @param {number} mixingRatio Mixing ratio\n * @returns {number}\n */\nfunction specificHumidityFromMixingRatio(mixingRatio) {\n    return mixingRatio / (1 + mixingRatio / 1000);\n}\n/**\n * Specific humidity from relative humidity.\n *\n * Approximation of the Magnus equation with the Sonntag 1990 coefficients.\n *\n * @param {number} relativeHumidity Relative humidity\n * @param {number} [pressure] Optional pressure\n * @param {number} [temp] Optional temperature\n * @returns {number}\n */\nfunction specificHumidity(relativeHumidity, pressure, temp) {\n    if (pressure === void 0) { pressure = P0; }\n    if (temp === void 0) { temp = T0; }\n    return relativeHumidity / 100 * (0.622 * waterVaporSaturationPressure(temp) / pressure) * 1000;\n}\n/**\n * Air density.\n *\n * Analytic equation from Avogadro\'s Law.\n *\n * @param {number} relativeHumidity Relative humidity\n * @param {number} [pressure] Optional pressure\n * @param {number} [temp] Optional temperature\n * @returns {number}\n */\nfunction airDensity(relativeHumidity, pressure, temp) {\n    if (pressure === void 0) { pressure = P0; }\n    if (temp === void 0) { temp = T0; }\n    var Psat = waterVaporSaturationPressure(temp);\n    var Pv = relativeHumidity / 100 * Psat;\n    var Pd = pressure - Pv;\n    return 100 * (Pd * Md + Pv * Mv) / (R * (temp - K));\n}\n/**\n * Lifted Condensation Level.\n *\n * This is the altitude at which a mechanically lifted air parcel from the ground will condensate.\n *\n * It corresponds to the cloud base level when the clouds are formed by mechanical lifting.\n *\n * This approximation is known as the Espy equation with the Stull coefficient.\n *\n * @param {number} temp Temperature at 2m\n * @param {number} dewPoint Dew point at 2m\n * @returns {number}\n */\nfunction LCL(temp, dewPoint) {\n    return 126.7 * (temp - dewPoint);\n}\n/**\n * Moist adiabatic lapse rate from pressure and temperature.\n *\n * Copied from Roland Stull, Practical Meteorology (copylefted, available online).\n *\n * Rather complex approximation based on the Magnus-Tetens equation and the barometric equation.\n *\n * @param {number} temp Temperature\n * @param {number} [pressure] Optional pressure\n * @returns {number}\n */\nfunction gammaMoist(temp, pressure) {\n    if (pressure === void 0) { pressure = P0; }\n    var tK = temp - K;\n    var es = 6.113 * Math.exp(5423 * (-1 / K - 1 / tK));\n    var rs = 0.622 * es / (pressure - es);\n    var gamma = G * 1e-3 * (1 + 8711 * rs / tK) / (1 + 1.35e7 * rs / (tK * tK));\n    return gamma;\n}\nvar HCR = 1.4;\n/**\n * Adiabatic expansion rate from pressure change rate.\n *\n * This equation allows to calculate the expansion ratio of an air parcel from the\n * the previous pressure and the new pressure.\n *\n * An adiabatic expansion is an isentropic process that is governed by the Ideal gas law\n * in general and the constant entropy relationship in particular:\n * (P / P0) = (V / V0) ^ gamma\n * Where P=pressure, V=volume, gamma=heat capacity ratio (1.4 for air, a diatomic gas)\n *\n * Analytic equation.\n *\n * @param {number} volume0 Old volume\n * @param {number} pressure New pressure\n * @param {number} pressure0 Old pressure\n * @returns {number}\n */\nfunction adiabaticExpansion(volume0, pressure, pressure0) {\n    if (pressure0 === void 0) { pressure0 = P0; }\n    return volume0 * Math.pow(pressure0 / pressure, 1 / HCR);\n}\n/**\n * Adiabatic cooling rate from pressure change rate.\n *\n * This equation allows to calculate the cooling ratio of an air parcel from the\n * the previous pressure and the new pressure.\n *\n * It is by combining this equation with the barometric equation\n * that the adiabatic lapse rate of dry air can be obtained.\n *\n * An adiabatic expansion is an isentropic process that is governed by the Ideal gas law\n * in general and the constant entropy relationship in particular:\n * (P / P0) = (V / V0) ^ gamma\n * Where P=pressure, V=volume, gamma=heat capacity ratio (1.4 for air, a diatomic gas)\n *\n * Keep in mind that if you intend to use this method to calculate a rate relative\n * to height in meters, you will need very precise altitude calculations for good\n * results. As the dry adiabatic rate is a constant that does not depend on the\n * temperature or the pressure, most of the time you will be better off simply\n * using the `gamma` constant.\n *\n * https://en.wikipedia.org/wiki/Ideal_gas_law contains a very good\n * introduction to this subject.\n *\n * Analytic equation.\n *\n * @example\n * // Compute the adiabatic cooling per meter\n * // when rising from 0m AMSL to 100m AMSL starting at 15°C\n *\n * const gamma = (15 - velitherm.adiabaticCooling(15,\n *                       velitherm.pressureFromStandardAltitude(100),\n *                       velitherm.pressureFromStandardAltitude(0))\n *                ) / 100;\n *\n * // It should be very close to the provided constant\n * assert(Math.abs(gamma - velitherm.gamma) < 1e-5)\n *\n * @param {number} temp0 Old temperature\n * @param {number} pressure New pressure\n * @param {number} pressure0 Old pressure\n * @returns {number}\n */\nfunction adiabaticCooling(temp0, pressure, pressure0) {\n    if (pressure0 === void 0) { pressure0 = P0; }\n    return (temp0 - K) * Math.pow(pressure / pressure0, (HCR - 1) / HCR) + K;\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./src/thermalWeather.js\n\nfunction calculateCloudbase(hum, press, temp, elev) {\n  var cloudbase;\n  var seaLevelPress = calculateSeaLevelPressure(temp, press, elev);\n  var specHum = specificHumidity(hum, press, temp);\n  for (var i = elev;; i++) {\n    var pressureAtAlt = pressureFromAltitude(i, seaLevelPress, temp);\n    var tempAtAlt = temp - i * gamma;\n    var relHumAtAlt = relativeHumidity(specHum, pressureAtAlt, tempAtAlt);\n    if (relHumAtAlt >= 100) {\n      cloudbase = i;\n      break;\n    }\n  }\n  var lclCB = LCL(temp, dewPoint(relativeHumidity(specHum, press, temp), temp));\n  modifyThermalDom(createThermalWeatherHTML(cloudbase, lclCB.toFixed(0)));\n}\nfunction createThermalWeatherHTML(cB, lclCB) {\n  return "\\n        <h2>The cloudbase is currently at:</h2>\\n        <h2>".concat(Number.parseFloat(cB).toFixed(0), " meters</h2>\\n        <h3>The LCL cloudbase is <span>").concat(Number.parseFloat(lclCB).toFixed(0), " meters.</span></h3>\\n    ");\n}\nfunction modifyThermalDom(thermalHTML) {\n  var thermalDiv = document.querySelector(\'.thermal-weather\');\n  thermalDiv.innerHTML = \'\';\n  thermalDiv.insertAdjacentHTML(\'afterbegin\', thermalHTML);\n}\nfunction calculateSeaLevelPressure(temp, press, elev) {\n  return press * Math.pow(1 - 0.0065 * elev / (temp + 0.0065 * elev + 273.15), -5.257);\n}\n;// CONCATENATED MODULE: ./src/currentWeather.js\nfunction currentWeather_typeof(obj) { "@babel/helpers - typeof"; return currentWeather_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, currentWeather_typeof(obj); }\nfunction currentWeather_slicedToArray(arr, i) { return currentWeather_arrayWithHoles(arr) || currentWeather_iterableToArrayLimit(arr, i) || currentWeather_unsupportedIterableToArray(arr, i) || currentWeather_nonIterableRest(); }\nfunction currentWeather_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction currentWeather_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return currentWeather_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return currentWeather_arrayLikeToArray(o, minLen); }\nfunction currentWeather_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction currentWeather_iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction currentWeather_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction currentWeather_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ currentWeather_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == currentWeather_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return currentWeather_typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (currentWeather_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (currentWeather_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction currentWeather_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction currentWeather_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { currentWeather_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { currentWeather_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar elevation;\nfunction getCurrentWeatherHTML() {\n  return _getCurrentWeatherHTML.apply(this, arguments);\n}\nfunction _getCurrentWeatherHTML() {\n  _getCurrentWeatherHTML = currentWeather_asyncToGenerator( /*#__PURE__*/currentWeather_regeneratorRuntime().mark(function _callee() {\n    var weatherData, weatherDataObj;\n    return currentWeather_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return fetchCurrWeatherData();\n        case 3:\n          weatherData = _context.sent;\n          weatherDataObj = getUsedWeatherData(weatherData);\n          setBackgroundImg(weatherDataObj.currWeatherPropertyDesc);\n          calculateCloudbase(weatherDataObj.currWeatherHum, weatherDataObj.currWeatherPress, weatherDataObj.currWeatherTemp, elevation);\n          return _context.abrupt("return", createCurrentWeatherHTML(weatherDataObj));\n        case 10:\n          _context.prev = 10;\n          _context.t0 = _context["catch"](0);\n          return _context.abrupt("return", "\\n        <div class=\\"flex-center-column\\" style=\\"grid-column: span 4;\\">\\n            <h2>Please try again!</h2>\\n            <h4>The data didn\'t reach us or the location was not found!</h4>\\n        </div>\\n    ");\n        case 13:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, null, [[0, 10]]);\n  }));\n  return _getCurrentWeatherHTML.apply(this, arguments);\n}\nfunction fetchCurrWeatherData() {\n  return _fetchCurrWeatherData.apply(this, arguments);\n}\nfunction _fetchCurrWeatherData() {\n  _fetchCurrWeatherData = currentWeather_asyncToGenerator( /*#__PURE__*/currentWeather_regeneratorRuntime().mark(function _callee2() {\n    var _yield$getLocationCoo, _yield$getLocationCoo2, lat, lon, elev, url, response, weatherData;\n    return currentWeather_regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return getLocationCoords();\n        case 2:\n          _yield$getLocationCoo = _context2.sent;\n          _yield$getLocationCoo2 = currentWeather_slicedToArray(_yield$getLocationCoo, 3);\n          lat = _yield$getLocationCoo2[0];\n          lon = _yield$getLocationCoo2[1];\n          elev = _yield$getLocationCoo2[2];\n          elevation = elev;\n          url = "https://api.openweathermap.org/data/2.5/weather?lat=".concat(lat, "&lon=").concat(lon, "&appid=").concat(apiKey, "&units=metric");\n          _context2.next = 11;\n          return fetch(url);\n        case 11:\n          response = _context2.sent;\n          _context2.next = 14;\n          return response.json();\n        case 14:\n          weatherData = _context2.sent;\n          return _context2.abrupt("return", weatherData);\n        case 16:\n        case "end":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _fetchCurrWeatherData.apply(this, arguments);\n}\nfunction getUsedWeatherData(weatherDataObj) {\n  var _currWeather;\n  var currWeather = (_currWeather = {\n    currWeatherLocation: weatherDataObj.name,\n    currWeatherCoord: "".concat(weatherDataObj.coord.lat, ", ").concat(weatherDataObj.coord.lon),\n    currWeatherProperty: weatherDataObj.weather[0].main,\n    currWeatherPropertyDesc: weatherDataObj.weather[0].description,\n    currWeatherID: weatherDataObj.weather[0].id,\n    currWeatherIcon: weatherDataObj.weather[0].icon,\n    currWeatherTemp: weatherDataObj.main.temp,\n    currWeatherTempFL: weatherDataObj.main.feels_like,\n    currWeatherTempMin: weatherDataObj.main.temp_min,\n    currWeatherTempMax: weatherDataObj.main.temp_max\n  }, _defineProperty(_currWeather, "currWeatherTempMax", weatherDataObj.main.temp_max), _defineProperty(_currWeather, "currWeatherPress", weatherDataObj.main.pressure), _defineProperty(_currWeather, "currWeatherHum", weatherDataObj.main.humidity), _defineProperty(_currWeather, "currWeatherVis", weatherDataObj.visibility), _defineProperty(_currWeather, "currWeatherWindSpeed", weatherDataObj.wind.speed), _defineProperty(_currWeather, "currWeatherWindDir", weatherDataObj.wind.deg), _defineProperty(_currWeather, "currWeatherClouds", weatherDataObj.clouds.all), _currWeather);\n  return currWeather;\n}\nfunction createCurrentWeatherHTML(filteredWeatherDataObj) {\n  var imgURL = "http://openweathermap.org/img/wn/".concat(filteredWeatherDataObj.currWeatherIcon, "@2x.png");\n  var windArrowDeg = calculateWindDirection(filteredWeatherDataObj.currWeatherWindDir);\n  var template = "\\n            <div class=\\"curr-weather-location flex-center-column\\">\\n                <h2>Current weather at: <span>".concat(filteredWeatherDataObj.currWeatherLocation, "</span></h2>\\n                <h4><span>").concat(filteredWeatherDataObj.currWeatherCoord, "</span></h4>\\n            </div>\\n            <div class=\\"curr-weather-temp-wind weather-card-data-group flex-center-column\\">\\n                <div class=\\"curr-weather-icon flex-center-column weather-card-data-group\\">\\n                    <img src=\\"").concat(imgURL, "\\" alt=\\"Weather description icon: ").concat(filteredWeatherDataObj.currWeatherPropertyDesc, "\\">\\n                    <h4>").concat(filteredWeatherDataObj.currWeatherPropertyDesc, "</h4>\\n                </div>\\n                <div class=\\"curr-weather-temperature flex-center-column \\">\\n                    <h3>Temperature: ").concat(Number.parseFloat(filteredWeatherDataObj.currWeatherTemp).toFixed(1), " \\xB0C</h3>\\n                    <h2>Feels like: ").concat(Number.parseFloat(filteredWeatherDataObj.currWeatherTempFL).toFixed(1), " \\xB0C</h2>\\n                </div>\\n            </div>\\n            <div class=\\"curr-weather-wind flex-center-column weather-card-data-group\\">\\n                <svg style=\\"transform: rotate(").concat(windArrowDeg, "deg);\\" xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"32\\" height=\\"32\\" viewBox=\\"0 0 24 24\\"><path fill=\\"currentColor\\" d=\\"M13 18h-2v-8l-3.5 3.5l-1.42-1.42L12 6.16l5.92 5.92l-1.42 1.42L13 10v8M12 2a10 10 0 0 1 10 10a10 10 0 0 1-10 10A10 10 0 0 1 2 12A10 10 0 0 1 12 2m0 2a8 8 0 0 0-8 8a8 8 0 0 0 8 8a8 8 0 0 0 8-8a8 8 0 0 0-8-8Z\\"/></svg>\\n                <h4>").concat(filteredWeatherDataObj.currWeatherWindDir, "\\xB0</h4>\\n                <h4>Speed: ").concat(Number.parseFloat(filteredWeatherDataObj.currWeatherWindSpeed).toFixed(1), " m/s</h4>\\n            </div>\\n            <div class=\\"curr-weather-misc flex-center-column weather-card-data-group\\">\\n                <h5>Cloud cover: ").concat(filteredWeatherDataObj.currWeatherClouds, "%</h5>\\n                <h5>Air pressure: ").concat(filteredWeatherDataObj.currWeatherPress, " hPa</h5>\\n                <h5>Rel. humidity: ").concat(filteredWeatherDataObj.currWeatherHum, "%</h5>\\n                <h5>Visibility: ").concat(filteredWeatherDataObj.currWeatherVis, " m</h5>\\n            </div>\\n\\n    ");\n  return template;\n}\n;// CONCATENATED MODULE: ./src/index.js\nfunction src_typeof(obj) { "@babel/helpers - typeof"; return src_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, src_typeof(obj); }\nfunction src_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ src_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == src_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction src_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction src_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { src_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { src_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\nvar locationInput = document.querySelector(\'#location\');\nvar locationInputValue = locationInput.value;\nvar apiKey = \'d64d5c0808808df9dcde98fb9640bcfc\';\nvar contactBtn = document.querySelector(\'footer > svg\');\nvar currentWeatherDiv = document.querySelector(\'.current-weather\');\nvar mainWeatherDisplay = document.querySelector(\'main\');\nvar searchButton = document.querySelector(\'.location-search-btn\');\nfunction revealContact() {\n  contactBtn.classList.toggle(\'rotated\');\n  document.querySelector(\'.footer-contact\').classList.toggle(\'hidden\');\n}\nfunction populateCurrWeatherElems() {\n  return _populateCurrWeatherElems.apply(this, arguments);\n}\nfunction _populateCurrWeatherElems() {\n  _populateCurrWeatherElems = src_asyncToGenerator( /*#__PURE__*/src_regeneratorRuntime().mark(function _callee() {\n    var currWeatherHTML;\n    return src_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          currentWeatherDiv.innerHTML = "";\n          currentWeatherDiv.innerHTML = \'<div style="grid-column: span 4;" class="spinner">\';\n          _context.next = 4;\n          return getCurrentWeatherHTML();\n        case 4:\n          currWeatherHTML = _context.sent;\n          currentWeatherDiv.innerHTML = "";\n          currentWeatherDiv.insertAdjacentHTML(\'afterbegin\', currWeatherHTML);\n        case 7:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _populateCurrWeatherElems.apply(this, arguments);\n}\nfunction populateForecastWeatherElems() {\n  return _populateForecastWeatherElems.apply(this, arguments);\n}\nfunction _populateForecastWeatherElems() {\n  _populateForecastWeatherElems = src_asyncToGenerator( /*#__PURE__*/src_regeneratorRuntime().mark(function _callee2() {\n    var forecastWeatherElem;\n    return src_regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (document.querySelector(\'.forecast-weather\')) mainWeatherDisplay.removeChild(mainWeatherDisplay.lastElementChild);\n          _context2.next = 3;\n          return getForecastWeatherHTML();\n        case 3:\n          forecastWeatherElem = _context2.sent;\n          mainWeatherDisplay.insertAdjacentElement(\'beforeend\', forecastWeatherElem);\n        case 5:\n        case "end":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _populateForecastWeatherElems.apply(this, arguments);\n}\ncontactBtn.addEventListener(\'click\', revealContact);\nlocationInput.addEventListener(\'blur\', function () {\n  if (locationInputValue === locationInput.value) return;\n  locationInputValue = locationInput.value;\n  populateCurrWeatherElems();\n  populateForecastWeatherElems();\n});\ndocument.addEventListener(\'keypress\', function (event) {\n  if (locationInputValue === locationInput.value) return;\n  locationInputValue = locationInput.value;\n  if (event.target === locationInput && event.key === \'Enter\') {\n    populateCurrWeatherElems();\n    populateForecastWeatherElems();\n  }\n});\nsearchButton.addEventListener(\'click\', function () {\n  if (locationInputValue === locationInput.value) return;\n  locationInputValue = locationInput.value;\n  populateCurrWeatherElems();\n  populateForecastWeatherElems();\n});\npopulateCurrWeatherElems();\npopulateForecastWeatherElems();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d0JBQXdCLEVBQUU7SUFDMUJFLDRCQUE0QixFQUFFO0VBQ2xDO0FBQ0osQ0FBQyxDQUFDO0FBQ0ZMLFlBQVksQ0FBQ1MsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFlBQU07RUFDekMsSUFBSTlLLGtCQUFrQixLQUFLRixhQUFhLENBQUNHLEtBQUssRUFBRTtFQUNoREQsa0JBQWtCLEdBQUdGLGFBQWEsQ0FBQ0csS0FBSztFQUNwQ3VLLHdCQUF3QixFQUFFO0VBQzFCRSw0QkFBNEIsRUFBRTtBQUN0QyxDQUFDLENBQUM7QUFDRkYsd0JBQXdCLEVBQUU7QUFDMUJFLDRCQUE0QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VhdGhlcmFwcC8uL3NyYy9tZXRVdGlsLmpzP2ZkZTQiLCJ3ZWJwYWNrOi8vd2VhdGhlcmFwcC8uL3NyYy9mb3JlY2FzdFdlYXRoZXIuanM/MzY2NiIsIndlYnBhY2s6Ly93ZWF0aGVyYXBwLy4vbm9kZV9tb2R1bGVzL3ZlbGl0aGVybS9kaXN0L2VzL2luZGV4LmpzPzA4YmYiLCJ3ZWJwYWNrOi8vd2VhdGhlcmFwcC8uL3NyYy90aGVybWFsV2VhdGhlci5qcz9lMzU4Iiwid2VicGFjazovL3dlYXRoZXJhcHAvLi9zcmMvY3VycmVudFdlYXRoZXIuanM/MGYzZSIsIndlYnBhY2s6Ly93ZWF0aGVyYXBwLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBpS2V5LCBsb2NhdGlvbklucHV0IH0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExvY2F0aW9uQ29vcmRzKCkge1xudHJ5IHsgICAgXG4gICAgY29uc3QgbG9jYXRpb25JbnB1dFZhbHVlID0gbG9jYXRpb25JbnB1dC52YWx1ZSB8fCAnQnVkYXBlc3QnO1xuICAgIGNvbnN0IGxvY2F0aW9uQ29vcmRzVXJsID0gYGh0dHA6Ly9hcGkub3BlbndlYXRoZXJtYXAub3JnL2dlby8xLjAvZGlyZWN0P3E9JHtsb2NhdGlvbklucHV0VmFsdWV9JmxpbWl0PTUmYXBwaWQ9JHthcGlLZXl9YFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobG9jYXRpb25Db29yZHNVcmwsIHttb2RlOiAnY29ycyd9KTtcbiAgICBjb25zdCByZXNEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IFtsYXQsIGxvbl0gPSBbcmVzRGF0YVswXS5sYXQsIHJlc0RhdGFbMF0ubG9uXVxuICAgIGNvbnN0IGVsZXZhdGlvbiA9IGF3YWl0IGdldExvY2F0aW9uRWxldmF0aW9uKGxhdCwgbG9uKTtcbiAgICBjb25zb2xlLmxvZyhlbGV2YXRpb24pO1xuICAgIHJldHVybiBbbGF0LCBsb24sIGVsZXZhdGlvbl07XG59IGNhdGNoKGVycikge1xuICAgIGNvbnNvbGUubG9nKGVycik7XG59XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRCYWNrZ3JvdW5kSW1nKHdlYXRoZXJEZXNjKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkudW5zcGxhc2guY29tL3NlYXJjaC9waG90b3M/JnF1ZXJ5PSR7d2VhdGhlckRlc2N9Jm9yaWVudGF0aW9uPWxhbmRzY2FwZSZjbGllbnRfaWQ9aW5VWkhaWXFRLWg3a0dXM2poanYwLWVWd0pJck9zTDlZQVRMNEFkWjRpMGAsIHttb2RlOiAnY29ycyd9KTtcbiAgICBjb25zdCBpbWdEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGNvbnN0IHJhbmRvbUltZ0Zyb21RdWVyeSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGltZ0RhdGEucmVzdWx0cy5sZW5ndGgpO1xuICAgIHNldEN1c3RvbUNTU1Byb3BlcnR5KCctLWJnLWltZycsIGB1cmwoJHtpbWdEYXRhLnJlc3VsdHNbcmFuZG9tSW1nRnJvbVF1ZXJ5XS51cmxzLmZ1bGx9KWApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXN0b21DU1NQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIG5ld1Byb3BWYWx1ZSkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIG5ld1Byb3BWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXaW5kRGlyZWN0aW9uKGRlZykge1xuICAgIHJldHVybiBNYXRoLmFicygzNjAgLSAoMTgwIC0gZGVnKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMb2NhdGlvbkVsZXZhdGlvbihsYXQsIGxvbikge1xuICAgIHRyeSB7ICAgIFxuICAgICAgICBjb25zdCByZXEgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkub3BlbnRvcG9kYXRhLm9yZy92MS9ldWRlbTI1bT9sb2NhdGlvbnM9JHtsYXR9LCR7bG9ufWApO1xuICAgICAgICBjb25zdCByZXFSZXMgPSBhd2FpdCByZXEuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVxUmVzLnJlc3VsdHNbMF0uZWxldmF0aW9uO1xuICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59IiwiaW1wb3J0IHsgZ2V0TG9jYXRpb25Db29yZHMsIHNldEN1c3RvbUNTU1Byb3BlcnR5LCBjYWxjdWxhdGVXaW5kRGlyZWN0aW9uIH0gZnJvbSBcIi4vbWV0VXRpbC5qc1wiO1xuaW1wb3J0IHsgYXBpS2V5IH0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuY29uc3QgZmVlbHNMaWtlSWNvblNWRyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj48cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIk0yNiAzMGgtNGEyLjAwNiAyLjAwNiAwIDAgMS0yLTJ2LTdhMi4wMDYgMi4wMDYgMCAwIDEtMi0ydi02YTIuOTQ2IDIuOTQ2IDAgMCAxIDMtM2g2YTIuOTQ2IDIuOTQ2IDAgMCAxIDMgM3Y2YTIuMDA2IDIuMDA2IDAgMCAxLTIgMnY3YTIuMDA2IDIuMDA2IDAgMCAxLTIgMnptLTUtMThhLjk0NS45NDUgMCAwIDAtMSAxdjZoMnY5aDR2LTloMnYtNmEuOTQ1Ljk0NSAwIDAgMC0xLTF6bTMtM2E0IDQgMCAxIDEgNC00YTQuMDEyIDQuMDEyIDAgMCAxLTQgNHptMC02YTIgMiAwIDEgMCAyIDJhMi4wMDYgMi4wMDYgMCAwIDAtMi0yek0xMCAyMC4xODRWMTJIOHY4LjE4NGEzIDMgMCAxIDAgMiAwelwiLz48cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIk05IDMwYTYuOTkzIDYuOTkzIDAgMCAxLTUtMTEuODlWN2E1IDUgMCAwIDEgMTAgMHYxMS4xMUE2Ljk5MyA2Ljk5MyAwIDAgMSA5IDMwWk05IDRhMy4wMDMgMy4wMDMgMCAwIDAtMyAzdjExLjk4M2wtLjMzMi4yOTlhNSA1IDAgMSAwIDYuNjY0IDBMMTIgMTguOTgzVjdhMy4wMDMgMy4wMDMgMCAwIDAtMy0zWlwiLz48L3N2Zz5cbmBcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZvcmVjYXN0V2VhdGhlckhUTUwoKSB7XG4gICAgdHJ5IHsgICAgXG4gICAgICAgIGNvbnN0IGZvcmVjYXN0V2VhdGhlckRhdGEgPSBhd2FpdCBmZXRjaEZvcmVjYXN0V2VhdGhlckRhdGEoKTtcbiAgICAgICAgY29uc3QgdXNlZEZvcmVjYXN0RGF0YSA9IGdldFVzZWRGb3JlY2FzdERhdGEoZm9yZWNhc3RXZWF0aGVyRGF0YSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JlY2FzdFdlYXRoZXJIVE1MKHVzZWRGb3JlY2FzdERhdGEpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgICBjb25zdCBmb3JlY2FzdEVyckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBmb3JlY2FzdEVyckRpdi5pbm5lckhUTUwgPSBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JlY2FzdC13ZWF0aGVyIHdlYXRoZXItY2FyZCBmbGV4LWNlbnRlci1jb2x1bW5cIj5cbiAgICAgICAgICAgIDxoMj5QbGVhc2UgdHJ5IGFnYWluITwvaDI+XG4gICAgICAgICAgICA8aDQ+VGhlIGRhdGEgZGlkbid0IHJlYWNoIHVzIG9yIHRoZSBsb2NhdGlvbiB3YXMgbm90IGZvdW5kITwvaDQ+XG4gICAgICAgIDwvZGl2PmBcbiAgICAgICAgcmV0dXJuIGZvcmVjYXN0RXJyRGl2O1xuICAgIFxuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hGb3JlY2FzdFdlYXRoZXJEYXRhKCkge1xuICAgIGNvbnN0IFtsYXQsIGxvbiwgZWxldl0gPSBhd2FpdCBnZXRMb2NhdGlvbkNvb3JkcygpO1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovL2FwaS5vcGVud2VhdGhlcm1hcC5vcmcvZGF0YS8yLjUvZm9yZWNhc3Q/bGF0PSR7bGF0fSZsb249JHtsb259JmFwcGlkPSR7YXBpS2V5fSZ1bml0cz1tZXRyaWNgO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBjb25zdCByZXNEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiByZXNEYXRhO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VkRm9yZWNhc3REYXRhKGZvcmVjYXN0T2JqKSB7XG4gICAgbGV0IGZvcmVjYXN0V2VhdGhlciA9IFtdO1xuICAgIGxldCBmb3JlY2FzdFdlYXRoZXJEYWlseSA9IHt9O1xuICAgIGNvbnN0IHdlZWtEYXlzID0gWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddO1xuXG4gICAgZm9yZWNhc3RPYmoubGlzdC5mb3JFYWNoKHRocmVlSG91ckZvcmVjYXN0ID0+IHtcbiAgICAgICAgY29uc3QgdXNlZFRocmVlSG91ckRhdGEgPSB7XG4gICAgICAgICAgICBmb3JlY2FzdERhdGVUaW1lOiB0aHJlZUhvdXJGb3JlY2FzdC5kdF90eHQsXG4gICAgICAgICAgICBmb3JlY2FzdERheTogd2Vla0RheXNbKG5ldyBEYXRlKHRocmVlSG91ckZvcmVjYXN0LmR0X3R4dC5zdWJzdHJpbmcoMCwgMTApKS5nZXRVVENEYXkoKSldLFxuICAgICAgICAgICAgZm9yZWNhc3RUaW1lOiB0aHJlZUhvdXJGb3JlY2FzdC5kdF90eHQuc3Vic3RyaW5nKDEwLCAxNiksXG4gICAgICAgICAgICBmb3JlY2FzdERheVBlcmlvZDogdGhyZWVIb3VyRm9yZWNhc3Quc3lzLnBvZCxcbiAgICAgICAgICAgIGZvcmVjYXN0SWNvbjogdGhyZWVIb3VyRm9yZWNhc3Qud2VhdGhlclswXS5pY29uLFxuICAgICAgICAgICAgZm9yZWNhc3REZXNjOiB0aHJlZUhvdXJGb3JlY2FzdC53ZWF0aGVyWzBdLm1haW4sXG4gICAgICAgICAgICBmb3JlY2FzdFRlbXBGZWx0OiB0aHJlZUhvdXJGb3JlY2FzdC5tYWluLmZlZWxzX2xpa2UsXG4gICAgICAgICAgICBmb3JlY2FzdFRlbXA6IHRocmVlSG91ckZvcmVjYXN0Lm1haW4udGVtcCxcbiAgICAgICAgICAgIGZvcmVjYXN0V2luZERpcjogdGhyZWVIb3VyRm9yZWNhc3Qud2luZC5kZWcsXG4gICAgICAgICAgICBmb3JlY2FzdFdpbmRTcGVlZDogdGhyZWVIb3VyRm9yZWNhc3Qud2luZC5zcGVlZCxcbiAgICAgICAgICAgIGZvcmVjYXN0V2luZEd1c3Q6IHRocmVlSG91ckZvcmVjYXN0LndpbmQuZ3VzdCxcbiAgICAgICAgfVxuICAgICAgICBmb3JlY2FzdFdlYXRoZXIucHVzaCh1c2VkVGhyZWVIb3VyRGF0YSk7XG4gICAgfSk7XG5cbiAgICBmb3JlY2FzdFdlYXRoZXIuZm9yRWFjaChmb3JlY2FzdE9iaiA9PiB7XG4gICAgICAgIGlmICghZm9yZWNhc3RXZWF0aGVyRGFpbHlbZm9yZWNhc3RPYmouZm9yZWNhc3REYXldKSB7XG4gICAgICAgICAgICBmb3JlY2FzdFdlYXRoZXJEYWlseVtmb3JlY2FzdE9iai5mb3JlY2FzdERheV0gPSBbXVxuICAgICAgICB9XG4gICAgICAgIGZvcmVjYXN0V2VhdGhlckRhaWx5W2ZvcmVjYXN0T2JqLmZvcmVjYXN0RGF5XS5wdXNoKGZvcmVjYXN0T2JqKTtcbiAgICB9KVxuICAgIHJldHVybiBmb3JlY2FzdFdlYXRoZXJEYWlseTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9yZWNhc3RXZWF0aGVySFRNTCh1c2VkRm9yZWNhc3REYXRhQXJyKSB7XG4gICAgY29uc3QgZGF5cyA9IE9iamVjdC5rZXlzKHVzZWRGb3JlY2FzdERhdGFBcnIpO1xuICAgIHNldEN1c3RvbUNTU1Byb3BlcnR5KCctLWZvcmVjYXN0LWdyaWQtbnVtJywgZGF5cy5sZW5ndGgpO1xuICAgIGNvbnN0IGZvcmVjYXN0V2VhdGhlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGZvcmVjYXN0V2VhdGhlckRpdi5jbGFzc0xpc3QuYWRkKCdmb3JlY2FzdC13ZWF0aGVyJywgJ3dlYXRoZXItY2FyZCcsICdmbGV4LWNlbnRlcicpO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRheXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRheURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkYXlEaXYuY2xhc3NMaXN0LmFkZCgnZm9yZWNhc3QtZGF5JywgYGZvcmVjYXN0LWRheS0ke2l9YCwgYCR7ZGF5c1tpXX1gLCAnZmxleC1jZW50ZXItY29sdW1uJyk7XG4gICAgICAgIGRheURpdi5pbm5lckhUTUwgPSBgPGgzPiR7ZGF5c1tpXX08L2gzPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYWlseS13ZWF0aGVyLWZvcmVjYXN0LXdyYXBwZXIgZmxleC1jZW50ZXJcIj48L2Rpdj5gO1xuICAgICAgICBcbiAgICAgICAgdXNlZEZvcmVjYXN0RGF0YUFycltkYXlzW2ldXS5mb3JFYWNoKHRocmVlSG91ckZvcmVjYXN0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltZ1VSTCA9IGBodHRwOi8vb3BlbndlYXRoZXJtYXAub3JnL2ltZy93bi8ke3RocmVlSG91ckZvcmVjYXN0LmZvcmVjYXN0SWNvbn1AMngucG5nYDtcbiAgICAgICAgICAgIGNvbnN0IHdpbmRBcnJvd0RlZyA9IGNhbGN1bGF0ZVdpbmREaXJlY3Rpb24odGhyZWVIb3VyRm9yZWNhc3QuZm9yZWNhc3RXaW5kRGlyKTtcbiAgICAgICAgICAgIGNvbnN0IGRhaWx5V2VhdGhlckZvcmVjYXN0VGVtcGxhdGUgPSBkYXlEaXYucXVlcnlTZWxlY3RvcignLmRhaWx5LXdlYXRoZXItZm9yZWNhc3Qtd3JhcHBlcicpO1xuICAgICAgICAgICAgY29uc3QgdGhyZWVIb3VyVGVtcGxhdGUgPSBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhaWx5LXdlYXRoZXItMy1ob3VyIGZsZXgtY2VudGVyLWNvbHVtbiB3ZWF0aGVyLWNhcmQtZGF0YS1ncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid2VhdGhlci1pY29uIGZsZXgtY2VudGVyLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGg1PiR7dGhyZWVIb3VyRm9yZWNhc3QuZm9yZWNhc3RUaW1lfTwvaDU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIiR7aW1nVVJMfVwiIGFsdD1cIiR7dGhyZWVIb3VyRm9yZWNhc3QuZm9yZWNhc3REZXNjfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGg2PiR7dGhyZWVIb3VyRm9yZWNhc3QuZm9yZWNhc3REZXNjfTwvaDY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid2VhdGhlci10ZW1wIGZsZXgtY2VudGVyLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGg2PiR7TnVtYmVyLnBhcnNlRmxvYXQodGhyZWVIb3VyRm9yZWNhc3QuZm9yZWNhc3RUZW1wKS50b0ZpeGVkKDEpfSDCsEM8L2g2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cImhlaWdodDogNjVweDtcIiBjbGFzcz1cImZsZXgtY2VudGVyLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNSA+RmVlbHMgbGlrZTo8L2g1PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNT4ke051bWJlci5wYXJzZUZsb2F0KHRocmVlSG91ckZvcmVjYXN0LmZvcmVjYXN0VGVtcEZlbHQpLnRvRml4ZWQoMSl9IMKwQzwvaDU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3ZWF0aGVyLXdpbmQgZmxleC1jZW50ZXItY29sdW1uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHN0eWxlPVwidHJhbnNmb3JtOiByb3RhdGUoJHt3aW5kQXJyb3dEZWd9ZGVnKTtcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBkPVwiTTEzIDE4aC0ydi04bC0zLjUgMy41bC0xLjQyLTEuNDJMMTIgNi4xNmw1LjkyIDUuOTJsLTEuNDIgMS40MkwxMyAxMHY4TTEyIDJhMTAgMTAgMCAwIDEgMTAgMTBhMTAgMTAgMCAwIDEtMTAgMTBBMTAgMTAgMCAwIDEgMiAxMkExMCAxMCAwIDAgMSAxMiAybTAgMmE4IDggMCAwIDAtOCA4YTggOCAwIDAgMCA4IDhhOCA4IDAgMCAwIDgtOGE4IDggMCAwIDAtOC04WlwiLz48L3N2Zz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNT4ke051bWJlci5wYXJzZUZsb2F0KHRocmVlSG91ckZvcmVjYXN0LmZvcmVjYXN0V2luZFNwZWVkKS50b0ZpeGVkKDEpfSBtL3M8L2g1PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGg2PiR7TnVtYmVyLnBhcnNlRmxvYXQodGhyZWVIb3VyRm9yZWNhc3QuZm9yZWNhc3RXaW5kR3VzdCkudG9GaXhlZCgxKX0gbS9zPC9oNj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgZGFpbHlXZWF0aGVyRm9yZWNhc3RUZW1wbGF0ZS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHRocmVlSG91clRlbXBsYXRlKTtcbiAgICAgICAgfSlcbiAgICAgICAgZm9yZWNhc3RXZWF0aGVyRGl2Lmluc2VydEFkamFjZW50RWxlbWVudCgnYmVmb3JlZW5kJywgZGF5RGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcmVjYXN0V2VhdGhlckRpdjtcbn0iLCIvKipcbiAqIHZlbGl2b2xlLmZyL21ldGVvLmd1cnUgQmFzaWMgVGhlcm1vZHluYW1pY3MgRXF1YXRpb25zIGZvciBTb2FyaW5nIEZsaWdodFxuICpcbiAqIENvcHlyaWdodCDCqSAyMDIyIE1vbXRjaGlsIE1vbXRjaGV2IDxtb210Y2hpbEBtb210Y2hldi5jb20+XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIExHUEwgTGljZW5zZSwgVmVyc2lvbiAzLjAgKHRoZSBcIkxpY2Vuc2VcIilcbiAqIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDogaHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9sZ3BsLTMuMC5lbi5odG1sXG4gKlxuICogQWxsIG1ldGhvZHMgdXNlOlxuICpcbiAqIFByZXNzdXJlIGluIGhQYVxuICpcbiAqIFRlbXBlcmF0dXJlIGluIMKwQ1xuICpcbiAqIEhlaWdodCBpbiBtZXRlcnNcbiAqXG4gKiBSZWxhdGl2ZSBodW1pZGl0eSBpbiAlIGZyb20gMCB0byAxMDBcbiAqXG4gKiBTcGVjaWZpYyBodW1pZGl0eSBpbiBnL2tnXG4gKlxuICogTWl4aW5nIHJhdGlvIGluIGcva2dcbiAqL1xuZXhwb3J0IHZhciB2ZWxpdGhlcm0gPSAndmVsaXRoZXJtJztcbi8qKlxuICogRWFydGgncyBhdmVyYWdlIGdyYXZpdHkgYWNjZWxlcmF0aW9uIChtL3MyKVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBHID0gOS44MTtcbi8qKlxuICogVGhlIHRoZXJtYWwgY2FwYWNpdHkgb2YgYWlyIChKL2tnKVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBDcCA9IDEwMDU7XG4vKipcbiAqIFRoZSBlbnRoYWxweSBvZiB2YXBvcml6YXRpb24gb2Ygd2F0ZXIgKEova2cpXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIEwgPSAyLjVlNjtcbi8qKlxuICogVGhlIGFkaWFiYXRpYyBsYXBzZSByYXRlIG9mIGRyeSBhaXIgKMKwQy9tKVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBnYW1tYSA9IDAuMDA5NzY7XG4vKipcbiAqIFRoZSBhdmVyYWdlIHNlYSBsZXZlbCBwcmVzc3VyZSAoaFBhKVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBQMCA9IDEwMTMuMjU7XG4vKipcbiAqIFRoZSB0ZW1wZXJhdHVyZSBvZiB0aGUgSUNBTyBzdGFuZGFyZCBhdG1vc3BoZXJlICjCsEMpXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFQwID0gMTU7XG4vKipcbiAqIFRoZSBzcGVjaWZpYyBnYXMgY29uc3RhbnQgb2YgZHJ5IGFpciBKLyhrZypLKVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBSZCA9IDI4Ny4wNTg7XG4vKipcbiAqIFRoZSBzcGVjaWZpYyBnYXMgY29uc3RhbnQgb2Ygd2F0ZXIgdmFwb3IgSi8oa2cqSylcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgUnYgPSA0NjEuNDk1O1xuLyoqXG4gKiBNb2xhciBtYXNzIG9mIGRyeSBhaXIga2cvbW9sXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIE1kID0gMC4wMjg5NjUyO1xuLyoqXG4gKiBNb2xhciBtYXNzIG9mIHdhdGVyIHZhcG9yIGtnL21vbFxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBNdiA9IDAuMDE4MDE2O1xuLyoqXG4gKiBVbml2ZXJzYWwgZ2FzIGNvbnN0YW50IEovKGtnKm1vbClcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgUiA9IDguMzE0NDY7XG4vKipcbiAqIEFic29sdXRlIHplcm8gaW4gwrBDXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIEsgPSAtMjczLjE1O1xuLyoqXG4gKiBBbHRpdHVkZSBmcm9tIHByZXNzdXJlIHVzaW5nIHRoZSBiYXJvbWV0cmljIGZvcm11bGEgYW5kIElDQU8ncyBkZWZpbml0aW9uIG9mIHN0YW5kYXJkIGF0bW9zcGhlcmUuXG4gKlxuICogVGhpcyBpcyBhIHZlcnkgcm91Z2ggYXBwcm94aW1hdGlvbiB0aGF0IGlzIGFuIElDQU8gc3RhbmRhcmQuIEl0IGlzIHVzZWQgd2hlbiBjYWxjdWxhdGluZyBRTkguXG4gKiBJdCBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGUgcHJlc3N1cmUgYW5kIHRlbXBlcmF0dXJlIG9mIHRoZSBkYXkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHByZXNzdXJlIFByZXNzdXJlXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZXNzdXJlMF0gT3B0aW9uYWwgc2VhLWxldmVsIHByZXNzdXJlIG9mIHRoZSBkYXlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbHRpdHVkZUZyb21TdGFuZGFyZFByZXNzdXJlKHByZXNzdXJlLCBwcmVzc3VyZTApIHtcbiAgICBpZiAocHJlc3N1cmUwID09PSB2b2lkIDApIHsgcHJlc3N1cmUwID0gUDA7IH1cbiAgICByZXR1cm4gNDQzMzAuMCAqICgxLjAgLSBNYXRoLnBvdyhwcmVzc3VyZSAvIHByZXNzdXJlMCwgMSAvIDUuMjU1KSk7XG59XG4vKipcbiAqIFByZXNzdXJlIGZyb20gYWx0aXR1ZGUgdXNpbmcgdGhlIGJhcm9tZXRyaWMgZm9ybXVsYSBhbmQgSUNBTydzIGRlZmluaXRpb24gb2Ygc3RhbmRhcmQgYXRtb3NwaGVyZS5cbiAqXG4gKiBUaGlzIGlzIGEgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9uIHRoYXQgaXMgYW4gSUNBTyBzdGFuZGFyZC4gSXQgaXMgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIFFOSC5cbiAqIEl0IGRvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHRoZSBwcmVzc3VyZSBhbmQgdGVtcGVyYXR1cmUgb2YgdGhlIGRheS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVzc3VyZTBdIE9wdGlvbmFsIHNlYS1sZXZlbCBwcmVzc3VyZSBvZiB0aGUgZGF5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlc3N1cmVGcm9tU3RhbmRhcmRBbHRpdHVkZShoZWlnaHQsIHByZXNzdXJlMCkge1xuICAgIGlmIChwcmVzc3VyZTAgPT09IHZvaWQgMCkgeyBwcmVzc3VyZTAgPSBQMDsgfVxuICAgIHJldHVybiBwcmVzc3VyZTAgKiBNYXRoLnBvdygxIC0gaGVpZ2h0IC8gNDQzMzAuMCwgNS4yNTUpO1xufVxuLyoqXG4gKiBBbHRpdHVkZSBmcm9tIHByZXNzdXJlIHVzaW5nIHRoZSBoeXBzb21ldHJpYyBmb3JtdWxhLlxuICpcbiAqIFRoaXMgaXMgYSBiZXR0ZXIgZXF1YXRpb24gdGhhdCB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHByZXNzdXJlIGFuZCB0aGUgdGVtcGVyYXR1cmUgb2YgdGhlIGRheS5cbiAqIEl0IGlzIG5vdCBhIHN0YW5kYXJkIGFuZCBkaWZmZXJlbnQgd2VhdGhlciBpbnN0aXR1dGlvbnMgdXNlIHNsaWdodGx5IGRpZmZlcmVudCBwYXJhbWV0ZXJzLlxuICogSXQgaXMgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBRRkYuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHByZXNzdXJlIFByZXNzdXJlXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZXNzdXJlMF0gT3B0aW9uYWwgc2VhLWxldmVsIHByZXNzdXJlIG9mIHRoZSBkYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGVtcF0gT3B0aW9uYWwgYXZlcmFnZSB0ZW1wZXJhdHVyZSBmcm9tIHRoZSBncm91bmQgdG8gdGhlIGdpdmVuIGxldmVsXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWx0aXR1ZGVGcm9tUHJlc3N1cmUocHJlc3N1cmUsIHByZXNzdXJlMCwgdGVtcCkge1xuICAgIGlmIChwcmVzc3VyZTAgPT09IHZvaWQgMCkgeyBwcmVzc3VyZTAgPSBQMDsgfVxuICAgIGlmICh0ZW1wID09PSB2b2lkIDApIHsgdGVtcCA9IFQwOyB9XG4gICAgcmV0dXJuIChNYXRoLnBvdyhwcmVzc3VyZTAgLyBwcmVzc3VyZSwgMS4wIC8gNS4yNTcpIC0gMSkgKiAodGVtcCAtIEspIC8gMC4wMDY1O1xufVxuLyoqXG4gKiBQcmVzc3VyZSBmcm9tIGFsdGl0dWRlIHVzaW5nIHRoZSBoeXBzb21ldHJpYyBmb3JtdWxhLlxuICpcbiAqIFRoaXMgaXMgYSBiZXR0ZXIgZXF1YXRpb24gdGhhdCB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHByZXNzdXJlIGFuZCB0aGUgdGVtcGVyYXR1cmUgb2YgdGhlIGRheS5cbiAqIEl0IGlzIG5vdCBhIHN0YW5kYXJkIGFuZCBkaWZmZXJlbnQgd2VhdGhlciBpbnN0aXR1dGlvbnMgdXNlIHNsaWdodGx5IGRpZmZlcmVudCBwYXJhbWV0ZXJzLlxuICogSXQgaXMgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBRRkYuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlc3N1cmUwXSBPcHRpb25hbCBzZWEtbGV2ZWwgcHJlc3N1cmUgb2YgdGhlIGRheVxuICogQHBhcmFtIHtudW1iZXJ9IFt0ZW1wXSBPcHRpb25hbCBhdmVyYWdlIHRlbXBlcmF0dXJlIGZyb20gdGhlIGdyb3VuZCB0byB0aGUgZ2l2ZW4gbGV2ZWxcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVzc3VyZUZyb21BbHRpdHVkZShoZWlnaHQsIHByZXNzdXJlMCwgdGVtcCkge1xuICAgIGlmIChwcmVzc3VyZTAgPT09IHZvaWQgMCkgeyBwcmVzc3VyZTAgPSBQMDsgfVxuICAgIGlmICh0ZW1wID09PSB2b2lkIDApIHsgdGVtcCA9IFQwOyB9XG4gICAgcmV0dXJuIHByZXNzdXJlMCAqIE1hdGgucG93KDEuMCAtIDAuMDA2NSAqIGhlaWdodCAvICh0ZW1wIC0gSyArIDAuMDA2NSAqIGhlaWdodCksIDUuMjU3KTtcbn1cbi8qKlxuICogKFNhdHVyYXRpb24pIFdhdGVyIHZhcG9yIHByZXNzdXJlLlxuICpcbiAqIENsYXVzaXVz4oCTQ2xhcGV5cm9uIGVxdWF0aW9uIC0gdGhlIG1vc3QgZnVuZGFtZW50YWwgZXF1YXRpb24gaW4gd2VhdGhlciBzY2llbmNlLlxuICpcbiAqIFRoaXMgaXMgdGhlIE1hZ251cy1UZXRlbnMgYXBwcm94aW1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGVtcCBUZW1wZXJhdHVyZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhdGVyVmFwb3JTYXR1cmF0aW9uUHJlc3N1cmUodGVtcCkge1xuICAgIGlmICh0ZW1wID09PSB2b2lkIDApIHsgdGVtcCA9IFQwOyB9XG4gICAgcmV0dXJuIDYuMTA3OCAqIE1hdGguZXhwKDE3LjI3ICogdGVtcCAvICh0ZW1wICsgMjM3LjMpKTtcbn1cbi8qKlxuICogUmVsYXRpdmUgaHVtaWRpdHkgZnJvbSBzcGVjaWZpYyBodW1pZGl0eS5cbiAqXG4gKiBUaGlzIGlzIGZyb20gdGhlIE1hZ251cy1UZXRlbnMgYXBwcm94aW1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc3BlY2lmaWNIdW1pZGl0eSBTcGVjaWZpYyBodW1pZGl0eVxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVzc3VyZV0gT3B0aW9uYWwgcHJlc3N1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGVtcF0gT3B0aW9uYWwgdGVtcGVyYXR1cmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWxhdGl2ZUh1bWlkaXR5KHNwZWNpZmljSHVtaWRpdHksIHByZXNzdXJlLCB0ZW1wKSB7XG4gICAgaWYgKHByZXNzdXJlID09PSB2b2lkIDApIHsgcHJlc3N1cmUgPSBQMDsgfVxuICAgIGlmICh0ZW1wID09PSB2b2lkIDApIHsgdGVtcCA9IFQwOyB9XG4gICAgcmV0dXJuIHNwZWNpZmljSHVtaWRpdHkgLyAoNi4yMiAqIHdhdGVyVmFwb3JTYXR1cmF0aW9uUHJlc3N1cmUodGVtcCkgLyBwcmVzc3VyZSk7XG59XG52YXIgU29ubnRhZ18xOTkwX2IgPSAxNy42MjtcbnZhciBTb25udGFnXzE5OTBfYyA9IDI0My4xMjtcbi8qKlxuICogRGV3IHBvaW50IGZyb20gcmVsYXRpdmUgaHVtaWRpdHkuXG4gKlxuICogQXBwcm94aW1hdGlvbiBvZiB0aGUgTWFnbnVzIGVxdWF0aW9uIHdpdGggdGhlIFNvbm50YWcgMTk5MCBjb2VmZmljaWVudHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlbGF0aXZlSHVtaWRpdHkgUmVsYXRpdmUgaHVtaWRpdHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGVtcF0gT3B0aW9uYWwgdGVtcGVyYXR1cmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXdQb2ludChyZWxhdGl2ZUh1bWlkaXR5LCB0ZW1wKSB7XG4gICAgaWYgKHRlbXAgPT09IHZvaWQgMCkgeyB0ZW1wID0gVDA7IH1cbiAgICB2YXIgZ2FtbWEgPSBNYXRoLmxvZyhyZWxhdGl2ZUh1bWlkaXR5IC8gMTAwKSArIFNvbm50YWdfMTk5MF9iICogdGVtcCAvIChTb25udGFnXzE5OTBfYyArIHRlbXApO1xuICAgIHJldHVybiBTb25udGFnXzE5OTBfYyAqIGdhbW1hIC8gKFNvbm50YWdfMTk5MF9iIC0gZ2FtbWEpO1xufVxuLyoqXG4gKiBSZWxhdGl2ZSBodW1pZGl0eSBmcm9tIGRldyBwb2ludC5cbiAqXG4gKiBBcHByb3hpbWF0aW9uIG9mIHRoZSBNYWdudXMgZXF1YXRpb24gd2l0aCB0aGUgU29ubnRhZyAxOTkwIGNvZWZmaWNpZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGV3UG9pbnQgUmVsYXRpdmUgaHVtaWRpdHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGVtcF0gT3B0aW9uYWwgdGVtcGVyYXR1cmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWxhdGl2ZUh1bWlkaXR5RnJvbURld1BvaW50KGRld1BvaW50LCB0ZW1wKSB7XG4gICAgaWYgKHRlbXAgPT09IHZvaWQgMCkgeyB0ZW1wID0gVDA7IH1cbiAgICB2YXIgZ2FtbWEgPSBkZXdQb2ludCAqIFNvbm50YWdfMTk5MF9iIC8gKGRld1BvaW50ICsgU29ubnRhZ18xOTkwX2MpO1xuICAgIHJldHVybiBNYXRoLmV4cChnYW1tYSAtIFNvbm50YWdfMTk5MF9iICogdGVtcCAvIChTb25udGFnXzE5OTBfYyArIHRlbXApKSAqIDEwMDtcbn1cbi8qKlxuICogTWl4aW5nIHJhdGlvIGZyb20gc3BlY2lmaWMgaHVtaWRpdHkuXG4gKlxuICogQW5hbHl0aWMgZXF1YXRpb24gZnJvbSB0aGUgZGVmaW5pdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc3BlY2lmaWNIdW1pZGl0eSBTcGVjaWZpYyBodW1pZGl0eVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluZ1JhdGlvKHNwZWNpZmljSHVtaWRpdHkpIHtcbiAgICByZXR1cm4gc3BlY2lmaWNIdW1pZGl0eSAvICgxIC0gc3BlY2lmaWNIdW1pZGl0eSAvIDEwMDApO1xufVxuLyoqXG4gKiBTcGVjaWZpYyBodW1pZGl0eSBmcm9tIG1peGluZyByYXRpby5cbiAqXG4gKiBBbmFseXRpYyBlcXVhdGlvbiBmcm9tIHRoZSBkZWZpbml0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaXhpbmdSYXRpbyBNaXhpbmcgcmF0aW9cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGVjaWZpY0h1bWlkaXR5RnJvbU1peGluZ1JhdGlvKG1peGluZ1JhdGlvKSB7XG4gICAgcmV0dXJuIG1peGluZ1JhdGlvIC8gKDEgKyBtaXhpbmdSYXRpbyAvIDEwMDApO1xufVxuLyoqXG4gKiBTcGVjaWZpYyBodW1pZGl0eSBmcm9tIHJlbGF0aXZlIGh1bWlkaXR5LlxuICpcbiAqIEFwcHJveGltYXRpb24gb2YgdGhlIE1hZ251cyBlcXVhdGlvbiB3aXRoIHRoZSBTb25udGFnIDE5OTAgY29lZmZpY2llbnRzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWxhdGl2ZUh1bWlkaXR5IFJlbGF0aXZlIGh1bWlkaXR5XG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZXNzdXJlXSBPcHRpb25hbCBwcmVzc3VyZVxuICogQHBhcmFtIHtudW1iZXJ9IFt0ZW1wXSBPcHRpb25hbCB0ZW1wZXJhdHVyZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwZWNpZmljSHVtaWRpdHkocmVsYXRpdmVIdW1pZGl0eSwgcHJlc3N1cmUsIHRlbXApIHtcbiAgICBpZiAocHJlc3N1cmUgPT09IHZvaWQgMCkgeyBwcmVzc3VyZSA9IFAwOyB9XG4gICAgaWYgKHRlbXAgPT09IHZvaWQgMCkgeyB0ZW1wID0gVDA7IH1cbiAgICByZXR1cm4gcmVsYXRpdmVIdW1pZGl0eSAvIDEwMCAqICgwLjYyMiAqIHdhdGVyVmFwb3JTYXR1cmF0aW9uUHJlc3N1cmUodGVtcCkgLyBwcmVzc3VyZSkgKiAxMDAwO1xufVxuLyoqXG4gKiBBaXIgZGVuc2l0eS5cbiAqXG4gKiBBbmFseXRpYyBlcXVhdGlvbiBmcm9tIEF2b2dhZHJvJ3MgTGF3LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWxhdGl2ZUh1bWlkaXR5IFJlbGF0aXZlIGh1bWlkaXR5XG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZXNzdXJlXSBPcHRpb25hbCBwcmVzc3VyZVxuICogQHBhcmFtIHtudW1iZXJ9IFt0ZW1wXSBPcHRpb25hbCB0ZW1wZXJhdHVyZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFpckRlbnNpdHkocmVsYXRpdmVIdW1pZGl0eSwgcHJlc3N1cmUsIHRlbXApIHtcbiAgICBpZiAocHJlc3N1cmUgPT09IHZvaWQgMCkgeyBwcmVzc3VyZSA9IFAwOyB9XG4gICAgaWYgKHRlbXAgPT09IHZvaWQgMCkgeyB0ZW1wID0gVDA7IH1cbiAgICB2YXIgUHNhdCA9IHdhdGVyVmFwb3JTYXR1cmF0aW9uUHJlc3N1cmUodGVtcCk7XG4gICAgdmFyIFB2ID0gcmVsYXRpdmVIdW1pZGl0eSAvIDEwMCAqIFBzYXQ7XG4gICAgdmFyIFBkID0gcHJlc3N1cmUgLSBQdjtcbiAgICByZXR1cm4gMTAwICogKFBkICogTWQgKyBQdiAqIE12KSAvIChSICogKHRlbXAgLSBLKSk7XG59XG4vKipcbiAqIExpZnRlZCBDb25kZW5zYXRpb24gTGV2ZWwuXG4gKlxuICogVGhpcyBpcyB0aGUgYWx0aXR1ZGUgYXQgd2hpY2ggYSBtZWNoYW5pY2FsbHkgbGlmdGVkIGFpciBwYXJjZWwgZnJvbSB0aGUgZ3JvdW5kIHdpbGwgY29uZGVuc2F0ZS5cbiAqXG4gKiBJdCBjb3JyZXNwb25kcyB0byB0aGUgY2xvdWQgYmFzZSBsZXZlbCB3aGVuIHRoZSBjbG91ZHMgYXJlIGZvcm1lZCBieSBtZWNoYW5pY2FsIGxpZnRpbmcuXG4gKlxuICogVGhpcyBhcHByb3hpbWF0aW9uIGlzIGtub3duIGFzIHRoZSBFc3B5IGVxdWF0aW9uIHdpdGggdGhlIFN0dWxsIGNvZWZmaWNpZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0ZW1wIFRlbXBlcmF0dXJlIGF0IDJtXG4gKiBAcGFyYW0ge251bWJlcn0gZGV3UG9pbnQgRGV3IHBvaW50IGF0IDJtXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gTENMKHRlbXAsIGRld1BvaW50KSB7XG4gICAgcmV0dXJuIDEyNi43ICogKHRlbXAgLSBkZXdQb2ludCk7XG59XG4vKipcbiAqIE1vaXN0IGFkaWFiYXRpYyBsYXBzZSByYXRlIGZyb20gcHJlc3N1cmUgYW5kIHRlbXBlcmF0dXJlLlxuICpcbiAqIENvcGllZCBmcm9tIFJvbGFuZCBTdHVsbCwgUHJhY3RpY2FsIE1ldGVvcm9sb2d5IChjb3B5bGVmdGVkLCBhdmFpbGFibGUgb25saW5lKS5cbiAqXG4gKiBSYXRoZXIgY29tcGxleCBhcHByb3hpbWF0aW9uIGJhc2VkIG9uIHRoZSBNYWdudXMtVGV0ZW5zIGVxdWF0aW9uIGFuZCB0aGUgYmFyb21ldHJpYyBlcXVhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGVtcCBUZW1wZXJhdHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVzc3VyZV0gT3B0aW9uYWwgcHJlc3N1cmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnYW1tYU1vaXN0KHRlbXAsIHByZXNzdXJlKSB7XG4gICAgaWYgKHByZXNzdXJlID09PSB2b2lkIDApIHsgcHJlc3N1cmUgPSBQMDsgfVxuICAgIHZhciB0SyA9IHRlbXAgLSBLO1xuICAgIHZhciBlcyA9IDYuMTEzICogTWF0aC5leHAoNTQyMyAqICgtMSAvIEsgLSAxIC8gdEspKTtcbiAgICB2YXIgcnMgPSAwLjYyMiAqIGVzIC8gKHByZXNzdXJlIC0gZXMpO1xuICAgIHZhciBnYW1tYSA9IEcgKiAxZS0zICogKDEgKyA4NzExICogcnMgLyB0SykgLyAoMSArIDEuMzVlNyAqIHJzIC8gKHRLICogdEspKTtcbiAgICByZXR1cm4gZ2FtbWE7XG59XG52YXIgSENSID0gMS40O1xuLyoqXG4gKiBBZGlhYmF0aWMgZXhwYW5zaW9uIHJhdGUgZnJvbSBwcmVzc3VyZSBjaGFuZ2UgcmF0ZS5cbiAqXG4gKiBUaGlzIGVxdWF0aW9uIGFsbG93cyB0byBjYWxjdWxhdGUgdGhlIGV4cGFuc2lvbiByYXRpbyBvZiBhbiBhaXIgcGFyY2VsIGZyb20gdGhlXG4gKiB0aGUgcHJldmlvdXMgcHJlc3N1cmUgYW5kIHRoZSBuZXcgcHJlc3N1cmUuXG4gKlxuICogQW4gYWRpYWJhdGljIGV4cGFuc2lvbiBpcyBhbiBpc2VudHJvcGljIHByb2Nlc3MgdGhhdCBpcyBnb3Zlcm5lZCBieSB0aGUgSWRlYWwgZ2FzIGxhd1xuICogaW4gZ2VuZXJhbCBhbmQgdGhlIGNvbnN0YW50IGVudHJvcHkgcmVsYXRpb25zaGlwIGluIHBhcnRpY3VsYXI6XG4gKiAoUCAvIFAwKSA9IChWIC8gVjApIF4gZ2FtbWFcbiAqIFdoZXJlIFA9cHJlc3N1cmUsIFY9dm9sdW1lLCBnYW1tYT1oZWF0IGNhcGFjaXR5IHJhdGlvICgxLjQgZm9yIGFpciwgYSBkaWF0b21pYyBnYXMpXG4gKlxuICogQW5hbHl0aWMgZXF1YXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZTAgT2xkIHZvbHVtZVxuICogQHBhcmFtIHtudW1iZXJ9IHByZXNzdXJlIE5ldyBwcmVzc3VyZVxuICogQHBhcmFtIHtudW1iZXJ9IHByZXNzdXJlMCBPbGQgcHJlc3N1cmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGlhYmF0aWNFeHBhbnNpb24odm9sdW1lMCwgcHJlc3N1cmUsIHByZXNzdXJlMCkge1xuICAgIGlmIChwcmVzc3VyZTAgPT09IHZvaWQgMCkgeyBwcmVzc3VyZTAgPSBQMDsgfVxuICAgIHJldHVybiB2b2x1bWUwICogTWF0aC5wb3cocHJlc3N1cmUwIC8gcHJlc3N1cmUsIDEgLyBIQ1IpO1xufVxuLyoqXG4gKiBBZGlhYmF0aWMgY29vbGluZyByYXRlIGZyb20gcHJlc3N1cmUgY2hhbmdlIHJhdGUuXG4gKlxuICogVGhpcyBlcXVhdGlvbiBhbGxvd3MgdG8gY2FsY3VsYXRlIHRoZSBjb29saW5nIHJhdGlvIG9mIGFuIGFpciBwYXJjZWwgZnJvbSB0aGVcbiAqIHRoZSBwcmV2aW91cyBwcmVzc3VyZSBhbmQgdGhlIG5ldyBwcmVzc3VyZS5cbiAqXG4gKiBJdCBpcyBieSBjb21iaW5pbmcgdGhpcyBlcXVhdGlvbiB3aXRoIHRoZSBiYXJvbWV0cmljIGVxdWF0aW9uXG4gKiB0aGF0IHRoZSBhZGlhYmF0aWMgbGFwc2UgcmF0ZSBvZiBkcnkgYWlyIGNhbiBiZSBvYnRhaW5lZC5cbiAqXG4gKiBBbiBhZGlhYmF0aWMgZXhwYW5zaW9uIGlzIGFuIGlzZW50cm9waWMgcHJvY2VzcyB0aGF0IGlzIGdvdmVybmVkIGJ5IHRoZSBJZGVhbCBnYXMgbGF3XG4gKiBpbiBnZW5lcmFsIGFuZCB0aGUgY29uc3RhbnQgZW50cm9weSByZWxhdGlvbnNoaXAgaW4gcGFydGljdWxhcjpcbiAqIChQIC8gUDApID0gKFYgLyBWMCkgXiBnYW1tYVxuICogV2hlcmUgUD1wcmVzc3VyZSwgVj12b2x1bWUsIGdhbW1hPWhlYXQgY2FwYWNpdHkgcmF0aW8gKDEuNCBmb3IgYWlyLCBhIGRpYXRvbWljIGdhcylcbiAqXG4gKiBLZWVwIGluIG1pbmQgdGhhdCBpZiB5b3UgaW50ZW5kIHRvIHVzZSB0aGlzIG1ldGhvZCB0byBjYWxjdWxhdGUgYSByYXRlIHJlbGF0aXZlXG4gKiB0byBoZWlnaHQgaW4gbWV0ZXJzLCB5b3Ugd2lsbCBuZWVkIHZlcnkgcHJlY2lzZSBhbHRpdHVkZSBjYWxjdWxhdGlvbnMgZm9yIGdvb2RcbiAqIHJlc3VsdHMuIEFzIHRoZSBkcnkgYWRpYWJhdGljIHJhdGUgaXMgYSBjb25zdGFudCB0aGF0IGRvZXMgbm90IGRlcGVuZCBvbiB0aGVcbiAqIHRlbXBlcmF0dXJlIG9yIHRoZSBwcmVzc3VyZSwgbW9zdCBvZiB0aGUgdGltZSB5b3Ugd2lsbCBiZSBiZXR0ZXIgb2ZmIHNpbXBseVxuICogdXNpbmcgdGhlIGBnYW1tYWAgY29uc3RhbnQuXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSWRlYWxfZ2FzX2xhdyBjb250YWlucyBhIHZlcnkgZ29vZFxuICogaW50cm9kdWN0aW9uIHRvIHRoaXMgc3ViamVjdC5cbiAqXG4gKiBBbmFseXRpYyBlcXVhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29tcHV0ZSB0aGUgYWRpYWJhdGljIGNvb2xpbmcgcGVyIG1ldGVyXG4gKiAvLyB3aGVuIHJpc2luZyBmcm9tIDBtIEFNU0wgdG8gMTAwbSBBTVNMIHN0YXJ0aW5nIGF0IDE1wrBDXG4gKlxuICogY29uc3QgZ2FtbWEgPSAoMTUgLSB2ZWxpdGhlcm0uYWRpYWJhdGljQ29vbGluZygxNSxcbiAqICAgICAgICAgICAgICAgICAgICAgICB2ZWxpdGhlcm0ucHJlc3N1cmVGcm9tU3RhbmRhcmRBbHRpdHVkZSgxMDApLFxuICogICAgICAgICAgICAgICAgICAgICAgIHZlbGl0aGVybS5wcmVzc3VyZUZyb21TdGFuZGFyZEFsdGl0dWRlKDApKVxuICogICAgICAgICAgICAgICAgKSAvIDEwMDtcbiAqXG4gKiAvLyBJdCBzaG91bGQgYmUgdmVyeSBjbG9zZSB0byB0aGUgcHJvdmlkZWQgY29uc3RhbnRcbiAqIGFzc2VydChNYXRoLmFicyhnYW1tYSAtIHZlbGl0aGVybS5nYW1tYSkgPCAxZS01KVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0ZW1wMCBPbGQgdGVtcGVyYXR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVzc3VyZSBOZXcgcHJlc3N1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVzc3VyZTAgT2xkIHByZXNzdXJlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRpYWJhdGljQ29vbGluZyh0ZW1wMCwgcHJlc3N1cmUsIHByZXNzdXJlMCkge1xuICAgIGlmIChwcmVzc3VyZTAgPT09IHZvaWQgMCkgeyBwcmVzc3VyZTAgPSBQMDsgfVxuICAgIHJldHVybiAodGVtcDAgLSBLKSAqIE1hdGgucG93KHByZXNzdXJlIC8gcHJlc3N1cmUwLCAoSENSIC0gMSkgLyBIQ1IpICsgSztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCAqIGFzIHZlbGl0aGVybSBmcm9tIFwidmVsaXRoZXJtXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDbG91ZGJhc2UoaHVtLCBwcmVzcywgdGVtcCwgZWxldikge1xuICAgIGxldCBjbG91ZGJhc2U7XG4gICAgY29uc3Qgc2VhTGV2ZWxQcmVzcyA9IGNhbGN1bGF0ZVNlYUxldmVsUHJlc3N1cmUodGVtcCwgcHJlc3MsIGVsZXYpO1xuICAgIGNvbnN0IHNwZWNIdW0gPSB2ZWxpdGhlcm0uc3BlY2lmaWNIdW1pZGl0eShodW0sIHByZXNzLCB0ZW1wKTtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gZWxldjsgOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJlc3N1cmVBdEFsdCA9IHZlbGl0aGVybS5wcmVzc3VyZUZyb21BbHRpdHVkZShpLCBzZWFMZXZlbFByZXNzLCB0ZW1wKTtcbiAgICAgICAgY29uc3QgdGVtcEF0QWx0ID0gdGVtcCAtIGkgKiB2ZWxpdGhlcm0uZ2FtbWE7XG4gICAgICAgIGxldCByZWxIdW1BdEFsdCA9IHZlbGl0aGVybS5yZWxhdGl2ZUh1bWlkaXR5KHNwZWNIdW0sIHByZXNzdXJlQXRBbHQsIHRlbXBBdEFsdCk7XG4gICAgICAgIFxuICAgICAgICBpZihyZWxIdW1BdEFsdCA+PSAxMDApIHtcbiAgICAgICAgICAgIGNsb3VkYmFzZSA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsY2xDQiA9IHZlbGl0aGVybS5MQ0wodGVtcCwgdmVsaXRoZXJtLmRld1BvaW50KHZlbGl0aGVybS5yZWxhdGl2ZUh1bWlkaXR5KHNwZWNIdW0sIHByZXNzLCB0ZW1wKSwgdGVtcCkpO1xuICAgIG1vZGlmeVRoZXJtYWxEb20oY3JlYXRlVGhlcm1hbFdlYXRoZXJIVE1MKGNsb3VkYmFzZSwgbGNsQ0IudG9GaXhlZCgwKSkpO1xufSBcblxuZnVuY3Rpb24gY3JlYXRlVGhlcm1hbFdlYXRoZXJIVE1MKGNCLCBsY2xDQikge1xuICAgIHJldHVybiBgXG4gICAgICAgIDxoMj5UaGUgY2xvdWRiYXNlIGlzIGN1cnJlbnRseSBhdDo8L2gyPlxuICAgICAgICA8aDI+JHtOdW1iZXIucGFyc2VGbG9hdChjQikudG9GaXhlZCgwKX0gbWV0ZXJzPC9oMj5cbiAgICAgICAgPGgzPlRoZSBMQ0wgY2xvdWRiYXNlIGlzIDxzcGFuPiR7TnVtYmVyLnBhcnNlRmxvYXQobGNsQ0IpLnRvRml4ZWQoMCl9IG1ldGVycy48L3NwYW4+PC9oMz5cbiAgICBgXG59XG5cbmZ1bmN0aW9uIG1vZGlmeVRoZXJtYWxEb20odGhlcm1hbEhUTUwpIHtcbiAgICBjb25zdCB0aGVybWFsRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRoZXJtYWwtd2VhdGhlcicpXG4gICAgdGhlcm1hbERpdi5pbm5lckhUTUwgPSAnJztcbiAgICB0aGVybWFsRGl2Lmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIHRoZXJtYWxIVE1MKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU2VhTGV2ZWxQcmVzc3VyZSh0ZW1wLCBwcmVzcywgZWxldikge1xuICAgIHJldHVybiBwcmVzcyAqIChNYXRoLnBvdygxIC0gKCgwLjAwNjUgKiBlbGV2KSAvICh0ZW1wICsgMC4wMDY1ICogZWxldiArIDI3My4xNSkpLCAtNS4yNTcpKTtcbn0iLCJpbXBvcnQgeyBnZXRMb2NhdGlvbkNvb3Jkcywgc2V0QmFja2dyb3VuZEltZywgY2FsY3VsYXRlV2luZERpcmVjdGlvbiB9IGZyb20gXCIuL21ldFV0aWwuanNcIjtcbmltcG9ydCB7IGFwaUtleSB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVDbG91ZGJhc2UgfSBmcm9tIFwiLi90aGVybWFsV2VhdGhlci5qc1wiO1xuXG5sZXQgZWxldmF0aW9uO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFdlYXRoZXJIVE1MKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHdlYXRoZXJEYXRhID0gYXdhaXQgZmV0Y2hDdXJyV2VhdGhlckRhdGEoKTtcbiAgICAgICAgY29uc3Qgd2VhdGhlckRhdGFPYmogPSBnZXRVc2VkV2VhdGhlckRhdGEod2VhdGhlckRhdGEpO1xuICAgICAgICBzZXRCYWNrZ3JvdW5kSW1nKHdlYXRoZXJEYXRhT2JqLmN1cnJXZWF0aGVyUHJvcGVydHlEZXNjKTtcbiAgICAgICAgY2FsY3VsYXRlQ2xvdWRiYXNlKHdlYXRoZXJEYXRhT2JqLmN1cnJXZWF0aGVySHVtLCB3ZWF0aGVyRGF0YU9iai5jdXJyV2VhdGhlclByZXNzLCB3ZWF0aGVyRGF0YU9iai5jdXJyV2VhdGhlclRlbXAsIGVsZXZhdGlvbik7XG4gICAgICAgIHJldHVybiBjcmVhdGVDdXJyZW50V2VhdGhlckhUTUwod2VhdGhlckRhdGFPYmopO1xuICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleC1jZW50ZXItY29sdW1uXCIgc3R5bGU9XCJncmlkLWNvbHVtbjogc3BhbiA0O1wiPlxuICAgICAgICAgICAgPGgyPlBsZWFzZSB0cnkgYWdhaW4hPC9oMj5cbiAgICAgICAgICAgIDxoND5UaGUgZGF0YSBkaWRuJ3QgcmVhY2ggdXMgb3IgdGhlIGxvY2F0aW9uIHdhcyBub3QgZm91bmQhPC9oND5cbiAgICAgICAgPC9kaXY+XG4gICAgYFxuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDdXJyV2VhdGhlckRhdGEoKSB7XG4gICAgY29uc3QgW2xhdCwgbG9uLCBlbGV2XSA9IGF3YWl0IGdldExvY2F0aW9uQ29vcmRzKCk7XG4gICAgZWxldmF0aW9uID0gZWxldjtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9hcGkub3BlbndlYXRoZXJtYXAub3JnL2RhdGEvMi41L3dlYXRoZXI/bGF0PSR7bGF0fSZsb249JHtsb259JmFwcGlkPSR7YXBpS2V5fSZ1bml0cz1tZXRyaWNgO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKVxuICAgIGNvbnN0IHdlYXRoZXJEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiB3ZWF0aGVyRGF0YTtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlZFdlYXRoZXJEYXRhKHdlYXRoZXJEYXRhT2JqKSB7XG4gICAgY29uc3QgY3VycldlYXRoZXIgPSB7XG4gICAgICAgIGN1cnJXZWF0aGVyTG9jYXRpb246IHdlYXRoZXJEYXRhT2JqLm5hbWUsXG4gICAgICAgIGN1cnJXZWF0aGVyQ29vcmQ6IGAke3dlYXRoZXJEYXRhT2JqLmNvb3JkLmxhdH0sICR7d2VhdGhlckRhdGFPYmouY29vcmQubG9ufWAsXG4gICAgICAgIGN1cnJXZWF0aGVyUHJvcGVydHk6IHdlYXRoZXJEYXRhT2JqLndlYXRoZXJbMF0ubWFpbixcbiAgICAgICAgY3VycldlYXRoZXJQcm9wZXJ0eURlc2M6IHdlYXRoZXJEYXRhT2JqLndlYXRoZXJbMF0uZGVzY3JpcHRpb24sXG4gICAgICAgIGN1cnJXZWF0aGVySUQ6IHdlYXRoZXJEYXRhT2JqLndlYXRoZXJbMF0uaWQsXG4gICAgICAgIGN1cnJXZWF0aGVySWNvbjogd2VhdGhlckRhdGFPYmoud2VhdGhlclswXS5pY29uLFxuICAgICAgICBjdXJyV2VhdGhlclRlbXA6IHdlYXRoZXJEYXRhT2JqLm1haW4udGVtcCxcbiAgICAgICAgY3VycldlYXRoZXJUZW1wRkw6IHdlYXRoZXJEYXRhT2JqLm1haW4uZmVlbHNfbGlrZSxcbiAgICAgICAgY3VycldlYXRoZXJUZW1wTWluOiB3ZWF0aGVyRGF0YU9iai5tYWluLnRlbXBfbWluLFxuICAgICAgICBjdXJyV2VhdGhlclRlbXBNYXg6IHdlYXRoZXJEYXRhT2JqLm1haW4udGVtcF9tYXgsXG4gICAgICAgIGN1cnJXZWF0aGVyVGVtcE1heDogd2VhdGhlckRhdGFPYmoubWFpbi50ZW1wX21heCxcbiAgICAgICAgY3VycldlYXRoZXJQcmVzczogd2VhdGhlckRhdGFPYmoubWFpbi5wcmVzc3VyZSxcbiAgICAgICAgY3VycldlYXRoZXJIdW06IHdlYXRoZXJEYXRhT2JqLm1haW4uaHVtaWRpdHksXG4gICAgICAgIGN1cnJXZWF0aGVyVmlzOiB3ZWF0aGVyRGF0YU9iai52aXNpYmlsaXR5LFxuICAgICAgICBjdXJyV2VhdGhlcldpbmRTcGVlZDogd2VhdGhlckRhdGFPYmoud2luZC5zcGVlZCxcbiAgICAgICAgY3VycldlYXRoZXJXaW5kRGlyOiB3ZWF0aGVyRGF0YU9iai53aW5kLmRlZyxcbiAgICAgICAgY3VycldlYXRoZXJDbG91ZHM6IHdlYXRoZXJEYXRhT2JqLmNsb3Vkcy5hbGwsXG4gICAgfVxuICAgIHJldHVybiBjdXJyV2VhdGhlcjtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVDdXJyZW50V2VhdGhlckhUTUwoZmlsdGVyZWRXZWF0aGVyRGF0YU9iaikge1xuICAgIGNvbnN0IGltZ1VSTCA9IGBodHRwOi8vb3BlbndlYXRoZXJtYXAub3JnL2ltZy93bi8ke2ZpbHRlcmVkV2VhdGhlckRhdGFPYmouY3VycldlYXRoZXJJY29ufUAyeC5wbmdgO1xuICAgIGNvbnN0IHdpbmRBcnJvd0RlZyA9IGNhbGN1bGF0ZVdpbmREaXJlY3Rpb24oZmlsdGVyZWRXZWF0aGVyRGF0YU9iai5jdXJyV2VhdGhlcldpbmREaXIpO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImN1cnItd2VhdGhlci1sb2NhdGlvbiBmbGV4LWNlbnRlci1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICA8aDI+Q3VycmVudCB3ZWF0aGVyIGF0OiA8c3Bhbj4ke2ZpbHRlcmVkV2VhdGhlckRhdGFPYmouY3VycldlYXRoZXJMb2NhdGlvbn08L3NwYW4+PC9oMj5cbiAgICAgICAgICAgICAgICA8aDQ+PHNwYW4+JHtmaWx0ZXJlZFdlYXRoZXJEYXRhT2JqLmN1cnJXZWF0aGVyQ29vcmR9PC9zcGFuPjwvaDQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjdXJyLXdlYXRoZXItdGVtcC13aW5kIHdlYXRoZXItY2FyZC1kYXRhLWdyb3VwIGZsZXgtY2VudGVyLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjdXJyLXdlYXRoZXItaWNvbiBmbGV4LWNlbnRlci1jb2x1bW4gd2VhdGhlci1jYXJkLWRhdGEtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIke2ltZ1VSTH1cIiBhbHQ9XCJXZWF0aGVyIGRlc2NyaXB0aW9uIGljb246ICR7ZmlsdGVyZWRXZWF0aGVyRGF0YU9iai5jdXJyV2VhdGhlclByb3BlcnR5RGVzY31cIj5cbiAgICAgICAgICAgICAgICAgICAgPGg0PiR7ZmlsdGVyZWRXZWF0aGVyRGF0YU9iai5jdXJyV2VhdGhlclByb3BlcnR5RGVzY308L2g0PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjdXJyLXdlYXRoZXItdGVtcGVyYXR1cmUgZmxleC1jZW50ZXItY29sdW1uIFwiPlxuICAgICAgICAgICAgICAgICAgICA8aDM+VGVtcGVyYXR1cmU6ICR7TnVtYmVyLnBhcnNlRmxvYXQoZmlsdGVyZWRXZWF0aGVyRGF0YU9iai5jdXJyV2VhdGhlclRlbXApLnRvRml4ZWQoMSl9IMKwQzwvaDM+XG4gICAgICAgICAgICAgICAgICAgIDxoMj5GZWVscyBsaWtlOiAke051bWJlci5wYXJzZUZsb2F0KGZpbHRlcmVkV2VhdGhlckRhdGFPYmouY3VycldlYXRoZXJUZW1wRkwpLnRvRml4ZWQoMSl9IMKwQzwvaDI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjdXJyLXdlYXRoZXItd2luZCBmbGV4LWNlbnRlci1jb2x1bW4gd2VhdGhlci1jYXJkLWRhdGEtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICA8c3ZnIHN0eWxlPVwidHJhbnNmb3JtOiByb3RhdGUoJHt3aW5kQXJyb3dEZWd9ZGVnKTtcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBkPVwiTTEzIDE4aC0ydi04bC0zLjUgMy41bC0xLjQyLTEuNDJMMTIgNi4xNmw1LjkyIDUuOTJsLTEuNDIgMS40MkwxMyAxMHY4TTEyIDJhMTAgMTAgMCAwIDEgMTAgMTBhMTAgMTAgMCAwIDEtMTAgMTBBMTAgMTAgMCAwIDEgMiAxMkExMCAxMCAwIDAgMSAxMiAybTAgMmE4IDggMCAwIDAtOCA4YTggOCAwIDAgMCA4IDhhOCA4IDAgMCAwIDgtOGE4IDggMCAwIDAtOC04WlwiLz48L3N2Zz5cbiAgICAgICAgICAgICAgICA8aDQ+JHtmaWx0ZXJlZFdlYXRoZXJEYXRhT2JqLmN1cnJXZWF0aGVyV2luZERpcn3CsDwvaDQ+XG4gICAgICAgICAgICAgICAgPGg0PlNwZWVkOiAke051bWJlci5wYXJzZUZsb2F0KGZpbHRlcmVkV2VhdGhlckRhdGFPYmouY3VycldlYXRoZXJXaW5kU3BlZWQpLnRvRml4ZWQoMSl9IG0vczwvaDQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjdXJyLXdlYXRoZXItbWlzYyBmbGV4LWNlbnRlci1jb2x1bW4gd2VhdGhlci1jYXJkLWRhdGEtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICA8aDU+Q2xvdWQgY292ZXI6ICR7ZmlsdGVyZWRXZWF0aGVyRGF0YU9iai5jdXJyV2VhdGhlckNsb3Vkc30lPC9oNT5cbiAgICAgICAgICAgICAgICA8aDU+QWlyIHByZXNzdXJlOiAke2ZpbHRlcmVkV2VhdGhlckRhdGFPYmouY3VycldlYXRoZXJQcmVzc30gaFBhPC9oNT5cbiAgICAgICAgICAgICAgICA8aDU+UmVsLiBodW1pZGl0eTogJHtmaWx0ZXJlZFdlYXRoZXJEYXRhT2JqLmN1cnJXZWF0aGVySHVtfSU8L2g1PlxuICAgICAgICAgICAgICAgIDxoNT5WaXNpYmlsaXR5OiAke2ZpbHRlcmVkV2VhdGhlckRhdGFPYmouY3VycldlYXRoZXJWaXN9IG08L2g1PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICBgXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufSIsImltcG9ydCB7IGdldEZvcmVjYXN0V2VhdGhlckhUTUwgfSBmcm9tIFwiLi9mb3JlY2FzdFdlYXRoZXIuanNcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRXZWF0aGVySFRNTCB9IGZyb20gXCIuL2N1cnJlbnRXZWF0aGVyLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBsb2NhdGlvbklucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xvY2F0aW9uJyk7XG5sZXQgbG9jYXRpb25JbnB1dFZhbHVlID0gbG9jYXRpb25JbnB1dC52YWx1ZTtcbmV4cG9ydCBjb25zdCBhcGlLZXkgPSAnZDY0ZDVjMDgwODgwOGRmOWRjZGU5OGZiOTY0MGJjZmMnO1xuY29uc3QgY29udGFjdEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Zvb3RlciA+IHN2ZycpO1xuY29uc3QgY3VycmVudFdlYXRoZXJEaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY3VycmVudC13ZWF0aGVyJyk7XG5jb25zdCBtYWluV2VhdGhlckRpc3BsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYWluJyk7XG5jb25zdCBzZWFyY2hCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9jYXRpb24tc2VhcmNoLWJ0bicpO1xuXG5mdW5jdGlvbiByZXZlYWxDb250YWN0KCkge1xuICAgIGNvbnRhY3RCdG4uY2xhc3NMaXN0LnRvZ2dsZSgncm90YXRlZCcpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb290ZXItY29udGFjdCcpLmNsYXNzTGlzdC50b2dnbGUoJ2hpZGRlbicpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwb3B1bGF0ZUN1cnJXZWF0aGVyRWxlbXMoKSB7XG4gICAgY3VycmVudFdlYXRoZXJEaXYuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBjdXJyZW50V2VhdGhlckRpdi5pbm5lckhUTUwgPSAnPGRpdiBzdHlsZT1cImdyaWQtY29sdW1uOiBzcGFuIDQ7XCIgY2xhc3M9XCJzcGlubmVyXCI+JztcbiAgICBjb25zdCBjdXJyV2VhdGhlckhUTUwgPSAgYXdhaXQgZ2V0Q3VycmVudFdlYXRoZXJIVE1MKCk7IFxuICAgIGN1cnJlbnRXZWF0aGVyRGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgY3VycmVudFdlYXRoZXJEaXYuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgY3VycldlYXRoZXJIVE1MKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGVGb3JlY2FzdFdlYXRoZXJFbGVtcygpIHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcmVjYXN0LXdlYXRoZXInKSkgbWFpbldlYXRoZXJEaXNwbGF5LnJlbW92ZUNoaWxkKG1haW5XZWF0aGVyRGlzcGxheS5sYXN0RWxlbWVudENoaWxkKTtcbiAgICBjb25zdCBmb3JlY2FzdFdlYXRoZXJFbGVtID0gIGF3YWl0IGdldEZvcmVjYXN0V2VhdGhlckhUTUwoKTtcbiAgICBcbiAgICBtYWluV2VhdGhlckRpc3BsYXkuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmVlbmQnLCBmb3JlY2FzdFdlYXRoZXJFbGVtKTtcbn1cblxuXG5jb250YWN0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcmV2ZWFsQ29udGFjdCk7XG5sb2NhdGlvbklucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgaWYgKGxvY2F0aW9uSW5wdXRWYWx1ZSA9PT0gbG9jYXRpb25JbnB1dC52YWx1ZSkgcmV0dXJuO1xuICAgIGxvY2F0aW9uSW5wdXRWYWx1ZSA9IGxvY2F0aW9uSW5wdXQudmFsdWU7XG4gICAgcG9wdWxhdGVDdXJyV2VhdGhlckVsZW1zKCk7XG4gICAgcG9wdWxhdGVGb3JlY2FzdFdlYXRoZXJFbGVtcygpO1xufSk7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIChldmVudCkgPT4ge1xuICAgIGlmIChsb2NhdGlvbklucHV0VmFsdWUgPT09IGxvY2F0aW9uSW5wdXQudmFsdWUpIHJldHVybjtcbiAgICBsb2NhdGlvbklucHV0VmFsdWUgPSBsb2NhdGlvbklucHV0LnZhbHVlO1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IGxvY2F0aW9uSW5wdXQgJiYgZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgIHBvcHVsYXRlQ3VycldlYXRoZXJFbGVtcygpO1xuICAgICAgICBwb3B1bGF0ZUZvcmVjYXN0V2VhdGhlckVsZW1zKCk7XG4gICAgfVxufSk7XG5zZWFyY2hCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgaWYgKGxvY2F0aW9uSW5wdXRWYWx1ZSA9PT0gbG9jYXRpb25JbnB1dC52YWx1ZSkgcmV0dXJuO1xuICAgIGxvY2F0aW9uSW5wdXRWYWx1ZSA9IGxvY2F0aW9uSW5wdXQudmFsdWU7XG4gICAgICAgIHBvcHVsYXRlQ3VycldlYXRoZXJFbGVtcygpO1xuICAgICAgICBwb3B1bGF0ZUZvcmVjYXN0V2VhdGhlckVsZW1zKCk7XG59KVxucG9wdWxhdGVDdXJyV2VhdGhlckVsZW1zKCk7XG5wb3B1bGF0ZUZvcmVjYXN0V2VhdGhlckVsZW1zKCk7XG4iXSwibmFtZXMiOlsiYXBpS2V5IiwibG9jYXRpb25JbnB1dCIsImdldExvY2F0aW9uQ29vcmRzIiwibG9jYXRpb25JbnB1dFZhbHVlIiwidmFsdWUiLCJsb2NhdGlvbkNvb3Jkc1VybCIsImZldGNoIiwibW9kZSIsInJlc3BvbnNlIiwianNvbiIsInJlc0RhdGEiLCJsYXQiLCJsb24iLCJnZXRMb2NhdGlvbkVsZXZhdGlvbiIsImVsZXZhdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJzZXRCYWNrZ3JvdW5kSW1nIiwid2VhdGhlckRlc2MiLCJpbWdEYXRhIiwicmFuZG9tSW1nRnJvbVF1ZXJ5IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicmVzdWx0cyIsImxlbmd0aCIsInNldEN1c3RvbUNTU1Byb3BlcnR5IiwidXJscyIsImZ1bGwiLCJwcm9wZXJ0eU5hbWUiLCJuZXdQcm9wVmFsdWUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJjYWxjdWxhdGVXaW5kRGlyZWN0aW9uIiwiZGVnIiwiYWJzIiwicmVxIiwicmVxUmVzIiwiZmVlbHNMaWtlSWNvblNWRyIsImdldEZvcmVjYXN0V2VhdGhlckhUTUwiLCJmZXRjaEZvcmVjYXN0V2VhdGhlckRhdGEiLCJmb3JlY2FzdFdlYXRoZXJEYXRhIiwidXNlZEZvcmVjYXN0RGF0YSIsImdldFVzZWRGb3JlY2FzdERhdGEiLCJjcmVhdGVGb3JlY2FzdFdlYXRoZXJIVE1MIiwiZm9yZWNhc3RFcnJEaXYiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwiZWxldiIsInVybCIsImZvcmVjYXN0T2JqIiwiZm9yZWNhc3RXZWF0aGVyIiwiZm9yZWNhc3RXZWF0aGVyRGFpbHkiLCJ3ZWVrRGF5cyIsImxpc3QiLCJmb3JFYWNoIiwidGhyZWVIb3VyRm9yZWNhc3QiLCJ1c2VkVGhyZWVIb3VyRGF0YSIsImZvcmVjYXN0RGF0ZVRpbWUiLCJkdF90eHQiLCJmb3JlY2FzdERheSIsIkRhdGUiLCJzdWJzdHJpbmciLCJnZXRVVENEYXkiLCJmb3JlY2FzdFRpbWUiLCJmb3JlY2FzdERheVBlcmlvZCIsInN5cyIsInBvZCIsImZvcmVjYXN0SWNvbiIsIndlYXRoZXIiLCJpY29uIiwiZm9yZWNhc3REZXNjIiwibWFpbiIsImZvcmVjYXN0VGVtcEZlbHQiLCJmZWVsc19saWtlIiwiZm9yZWNhc3RUZW1wIiwidGVtcCIsImZvcmVjYXN0V2luZERpciIsIndpbmQiLCJmb3JlY2FzdFdpbmRTcGVlZCIsInNwZWVkIiwiZm9yZWNhc3RXaW5kR3VzdCIsImd1c3QiLCJwdXNoIiwidXNlZEZvcmVjYXN0RGF0YUFyciIsImRheXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yZWNhc3RXZWF0aGVyRGl2IiwiY2xhc3NMaXN0IiwiYWRkIiwiZGF5RGl2IiwiaSIsImltZ1VSTCIsIndpbmRBcnJvd0RlZyIsImRhaWx5V2VhdGhlckZvcmVjYXN0VGVtcGxhdGUiLCJxdWVyeVNlbGVjdG9yIiwidGhyZWVIb3VyVGVtcGxhdGUiLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsImluc2VydEFkamFjZW50SFRNTCIsImluc2VydEFkamFjZW50RWxlbWVudCIsInZlbGl0aGVybSIsImNhbGN1bGF0ZUNsb3VkYmFzZSIsImh1bSIsInByZXNzIiwiY2xvdWRiYXNlIiwic2VhTGV2ZWxQcmVzcyIsImNhbGN1bGF0ZVNlYUxldmVsUHJlc3N1cmUiLCJzcGVjSHVtIiwic3BlY2lmaWNIdW1pZGl0eSIsInByZXNzdXJlQXRBbHQiLCJwcmVzc3VyZUZyb21BbHRpdHVkZSIsInRlbXBBdEFsdCIsImdhbW1hIiwicmVsSHVtQXRBbHQiLCJyZWxhdGl2ZUh1bWlkaXR5IiwibGNsQ0IiLCJMQ0wiLCJkZXdQb2ludCIsIm1vZGlmeVRoZXJtYWxEb20iLCJjcmVhdGVUaGVybWFsV2VhdGhlckhUTUwiLCJjQiIsInRoZXJtYWxIVE1MIiwidGhlcm1hbERpdiIsInBvdyIsImdldEN1cnJlbnRXZWF0aGVySFRNTCIsImZldGNoQ3VycldlYXRoZXJEYXRhIiwid2VhdGhlckRhdGEiLCJ3ZWF0aGVyRGF0YU9iaiIsImdldFVzZWRXZWF0aGVyRGF0YSIsImN1cnJXZWF0aGVyUHJvcGVydHlEZXNjIiwiY3VycldlYXRoZXJIdW0iLCJjdXJyV2VhdGhlclByZXNzIiwiY3VycldlYXRoZXJUZW1wIiwiY3JlYXRlQ3VycmVudFdlYXRoZXJIVE1MIiwiY3VycldlYXRoZXIiLCJjdXJyV2VhdGhlckxvY2F0aW9uIiwibmFtZSIsImN1cnJXZWF0aGVyQ29vcmQiLCJjb29yZCIsImN1cnJXZWF0aGVyUHJvcGVydHkiLCJkZXNjcmlwdGlvbiIsImN1cnJXZWF0aGVySUQiLCJpZCIsImN1cnJXZWF0aGVySWNvbiIsImN1cnJXZWF0aGVyVGVtcEZMIiwiY3VycldlYXRoZXJUZW1wTWluIiwidGVtcF9taW4iLCJjdXJyV2VhdGhlclRlbXBNYXgiLCJ0ZW1wX21heCIsInByZXNzdXJlIiwiaHVtaWRpdHkiLCJ2aXNpYmlsaXR5IiwiY2xvdWRzIiwiYWxsIiwiZmlsdGVyZWRXZWF0aGVyRGF0YU9iaiIsImN1cnJXZWF0aGVyV2luZERpciIsInRlbXBsYXRlIiwiY3VycldlYXRoZXJXaW5kU3BlZWQiLCJjdXJyV2VhdGhlckNsb3VkcyIsImN1cnJXZWF0aGVyVmlzIiwiY29udGFjdEJ0biIsImN1cnJlbnRXZWF0aGVyRGl2IiwibWFpbldlYXRoZXJEaXNwbGF5Iiwic2VhcmNoQnV0dG9uIiwicmV2ZWFsQ29udGFjdCIsInRvZ2dsZSIsInBvcHVsYXRlQ3VycldlYXRoZXJFbGVtcyIsImN1cnJXZWF0aGVySFRNTCIsInBvcHVsYXRlRm9yZWNhc3RXZWF0aGVyRWxlbXMiLCJyZW1vdmVDaGlsZCIsImxhc3RFbGVtZW50Q2hpbGQiLCJmb3JlY2FzdFdlYXRoZXJFbGVtIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwidGFyZ2V0Iiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///417\n')}},__webpack_require__={d:(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},__webpack_exports__={};__webpack_modules__[417](0,__webpack_exports__,__webpack_require__)})();